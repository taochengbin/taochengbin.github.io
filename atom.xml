<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ruby</title>
  
  <subtitle>Ruby</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-10-15T07:50:05.428Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>陶成彬</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VMware装Centos7虚拟机超详细安装步骤，以及配置网络ping通外网</title>
    <link href="http://example.com/2020/10/15/VMware%E8%A3%85Centos7%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B6%85%E8%AF%A6%E7%BB%86%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4%EF%BC%8C%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9Cping%E9%80%9A%E5%A4%96%E7%BD%91/"/>
    <id>http://example.com/2020/10/15/VMware%E8%A3%85Centos7%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B6%85%E8%AF%A6%E7%BB%86%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4%EF%BC%8C%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9Cping%E9%80%9A%E5%A4%96%E7%BD%91/</id>
    <published>2020-10-15T07:26:46.679Z</published>
    <updated>2020-10-15T07:50:05.428Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此博客记录如何在VMware安装centos7，以及配置网络ping通外网。</p><h2 id="VMware安装centos7详细步骤"><a href="#VMware安装centos7详细步骤" class="headerlink" title="VMware安装centos7详细步骤"></a>VMware安装centos7详细步骤</h2><p>1.新建虚拟机，选择典型模式，点击下一步。<br><img src="https://img-blog.csdnimg.cn/20200614183643200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>2.点击浏览，选择你本地下载的centos7镜像文件，下一步。<img src="https://img-blog.csdnimg.cn/20200614183725670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>3.给新建的虚拟机取名字，以及选择要安装的目录。下一步<img src="https://img-blog.csdnimg.cn/20200614183839464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>4.直接点击完成<br><img src="https://img-blog.csdnimg.cn/20200614183923718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>5.然后就会看到Linux界面，等待它安装提示下一步操作<br><img src="https://img-blog.csdnimg.cn/20200614184027619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>6.配置语言，点击继续<br><img src="https://img-blog.csdnimg.cn/20200614184109459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>7.点击网络和主机名，配置网络<img src="https://img-blog.csdnimg.cn/2020061418414111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>8.把右上方的网络，点击打开。配置可以暂时不管，点击左上角完成，点击2次。<br><img src="https://img-blog.csdnimg.cn/20200614184313387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>9.配置root账号的密码，待会安装完成进入Linux会提示登录。点击完成（2次）<img src="https://img-blog.csdnimg.cn/2020061418444472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>10.等待它安装完成<br><img src="https://img-blog.csdnimg.cn/20200614184550744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>11.安装完重启<img src="https://img-blog.csdnimg.cn/20200614184659210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>12.重启完后用刚刚设置的root账户密码登录。（前面输错密码了2次！！！不要在意这些细节！！）<br><img src="https://img-blog.csdnimg.cn/20200614184745134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>13.登录后，使用 ping <a href="http://www.baidu.com/">www.baidu.com</a> 命令，看能不能ping通（没配置网络，肯定会失败了啦）</p><h2 id="配置网络ping通外网"><a href="#配置网络ping通外网" class="headerlink" title="配置网络ping通外网"></a>配置网络ping通外网</h2><p>1.进入cmd，输入ipconfig /all 命令。查看本地Windows的ip，子网掩码。此刻注意ip：<strong>192.168.248</strong>.1<br><img src="https://img-blog.csdnimg.cn/20200614185313415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2.点击编辑，选中 虚拟网络编辑器。查看ip和子网掩码信息。<br><img src="https://img-blog.csdnimg.cn/20200614185846748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里ip，192.168.248.0。192.168.248前缀要跟之前windows的ip前缀一致<br><img src="https://img-blog.csdnimg.cn/20200614185954209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>NAT设置网关，前缀也是一致。192.168.248.2。记住，待会要配置<br><img src="https://img-blog.csdnimg.cn/20200614190750265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.返回Linux操作界面，输入cd /etc/sysconfig/network-scripts/，进入/etc/sysconfig/network-scripts/这个目录<br><img src="https://img-blog.csdnimg.cn/20200614191000759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4.修改网络配置文件，这里ifcfg-ens33.使用命令vi ifcfg-ens33<br><img src="https://img-blog.csdnimg.cn/20200614191239579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>按insert，进入编辑模式，配置ip等信息，编辑完后按 “：”，输入wq退出（图示是3-255之间的数，打字打错了）<br><img src="https://img-blog.csdnimg.cn/20200614192343260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200614192524613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>5.退出后。使用service network restart，重启网卡。接着ping <a href="http://www.baidu.com命令,若是图示则成功了./">www.baidu.com命令，若是图示则成功了。</a><br><img src="https://img-blog.csdnimg.cn/20200614192933502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;此博客记录如何在VMware安装centos7，以及配置网络ping通外网。&lt;/p&gt;
&lt;h2 id=&quot;VMware</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Maven打包错误：Execution default of goal org.springframew ork.boot_spring-boot-maven-plugin_2.1.8.RELEASE</title>
    <link href="http://example.com/2020/10/15/Maven%E6%89%93%E5%8C%85%E9%94%99%E8%AF%AF%EF%BC%9AExecution%20default%20of%20goal%20org.springframew%20ork.boot_spring-boot-maven-plugin_2.1.8.RELEASE/"/>
    <id>http://example.com/2020/10/15/Maven%E6%89%93%E5%8C%85%E9%94%99%E8%AF%AF%EF%BC%9AExecution%20default%20of%20goal%20org.springframew%20ork.boot_spring-boot-maven-plugin_2.1.8.RELEASE/</id>
    <published>2020-10-15T07:26:46.678Z</published>
    <updated>2020-10-15T07:49:43.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="打包fail失败错误信息"><a href="#打包fail失败错误信息" class="headerlink" title="打包fail失败错误信息"></a>打包fail失败错误信息</h2><p><img src="https://img-blog.csdnimg.cn/20200616193739408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h2><p>原因在于maven引入了这个，它会在打包时会去扫描项目main方法入口，如果没有就会如上报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;configuration&gt;</span><br><span class="line">    &lt;executable&gt;true&lt;&#x2F;executable&gt;</span><br><span class="line">  &lt;&#x2F;configuration&gt;</span><br><span class="line">&lt;&#x2F;plugin&gt;</span><br></pre></td></tr></table></figure><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><p>1.创建springboot启动类<br>2.更改pom.xml配置为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;configuration&gt;</span><br><span class="line">    &lt;executable&gt;true&lt;&#x2F;executable&gt;</span><br><span class="line">  &lt;&#x2F;configuration&gt;</span><br><span class="line">  &lt;executions&gt;</span><br><span class="line">    &lt;execution&gt;</span><br><span class="line">      &lt;phase&gt;none&lt;&#x2F;phase&gt;</span><br><span class="line">    &lt;&#x2F;execution&gt;</span><br><span class="line">  &lt;&#x2F;executions&gt;</span><br><span class="line">&lt;&#x2F;plugin&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;打包fail失败错误信息&quot;&gt;&lt;a href=&quot;#打包fail失败错误信息&quot; class=&quot;headerlink&quot; title=&quot;打包fail失败错误信息&quot;&gt;&lt;/a&gt;打包fail失败错误信息&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csd</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Maven编报错：No compiler is provided in this environment. Perhaps you are running on a JRE rather a JDK_</title>
    <link href="http://example.com/2020/10/15/Maven%E7%BC%96%E6%8A%A5%E9%94%99%EF%BC%9ANo%20compiler%20is%20provided%20in%20this%20environment.%20Perhaps%20you%20are%20running%20on%20a%20JRE%20rather%20a%20JDK_/"/>
    <id>http://example.com/2020/10/15/Maven%E7%BC%96%E6%8A%A5%E9%94%99%EF%BC%9ANo%20compiler%20is%20provided%20in%20this%20environment.%20Perhaps%20you%20are%20running%20on%20a%20JRE%20rather%20a%20JDK_/</id>
    <published>2020-10-15T07:26:46.676Z</published>
    <updated>2020-10-15T07:49:15.292Z</updated>
    
    <content type="html"><![CDATA[<h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><p>idea报错No compiler is provided in this environment. Perhaps you are running on a JRE rather a JDK?</p><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><p>方式1.pom.xml里面配置指定JDK路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;configuration&gt;</span><br><span class="line">    &lt;fork&gt;true&lt;&#x2F;fork&gt;</span><br><span class="line">    &lt;!--指定你的jdk地址--&gt;</span><br><span class="line">    &lt;executable&gt;</span><br><span class="line">      C:\Program Files\Java\jdk1.8.0_231\bin\javac.exe</span><br><span class="line">    &lt;&#x2F;executable&gt;</span><br><span class="line">  &lt;&#x2F;configuration&gt;</span><br><span class="line">&lt;&#x2F;plugin&gt;</span><br></pre></td></tr></table></figure><p>方式2.检查是否JDK环境变量配置正确。高版本的JDK安装会自动配置JDK环境变量，不要因为这个就不去配置，重新配置一次环境变量（踩坑）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;报错信息&quot;&gt;&lt;a href=&quot;#报错信息&quot; class=&quot;headerlink&quot; title=&quot;报错信息&quot;&gt;&lt;/a&gt;报错信息&lt;/h2&gt;&lt;p&gt;idea报错No compiler is provided in this environment. Perhaps you</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Maven引入第三方jar包，本地引入SDK包</title>
    <link href="http://example.com/2020/10/15/Maven%E5%BC%95%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9jar%E5%8C%85%EF%BC%8C%E6%9C%AC%E5%9C%B0%E5%BC%95%E5%85%A5SDK%E5%8C%85/"/>
    <id>http://example.com/2020/10/15/Maven%E5%BC%95%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9jar%E5%8C%85%EF%BC%8C%E6%9C%AC%E5%9C%B0%E5%BC%95%E5%85%A5SDK%E5%8C%85/</id>
    <published>2020-10-15T07:26:46.674Z</published>
    <updated>2020-10-15T07:48:51.204Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p><img src="https://img-blog.csdnimg.cn/20200623113824678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="maven-pom-xml配置"><a href="#maven-pom-xml配置" class="headerlink" title="maven pom.xml配置"></a>maven pom.xml配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;cn.aa&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;name&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.0.0&lt;&#x2F;version&gt;</span><br><span class="line">  &lt;scope&gt;system&lt;&#x2F;scope&gt;</span><br><span class="line">  &lt;systemPath&gt;$&#123;project.basedir&#125;&#x2F;lib&#x2F;sdk.jar&lt;&#x2F;systemPath&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;图示&quot;&gt;&lt;a href=&quot;#图示&quot; class=&quot;headerlink&quot; title=&quot;图示&quot;&gt;&lt;/a&gt;图示&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200623113824678.png?x-oss-proc</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JDK源码深入学习之ArrayList</title>
    <link href="http://example.com/2020/10/15/JDK%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8BArrayList/"/>
    <id>http://example.com/2020/10/15/JDK%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8BArrayList/</id>
    <published>2020-10-15T07:26:46.673Z</published>
    <updated>2020-10-15T07:48:28.881Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="ArrayList概述"><a href="#ArrayList概述" class="headerlink" title="ArrayList概述"></a>ArrayList概述</h2><p>ArrayList：是一个可以动态改变大小的数组。<br>ArrayList：直接用的数组下标取的元素，所以查询效率较高。但是由于增删涉及数组元素的移动，所以增删效率比较低<br>ArrayList：线程不安全的，建议使用Vector或者CopyOnWriteArrayList<br>ArrayList：继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。设计初衷就是为了解决数组大小不可动态拓展的局限性。<br>ArrayList继承关系图：<br><img src="https://img-blog.csdnimg.cn/20200702161032858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="ArrayList源码解读（JDK1-8）"><a href="#ArrayList源码解读（JDK1-8）" class="headerlink" title="ArrayList源码解读（JDK1.8）"></a>ArrayList源码解读（JDK1.8）</h2><h3 id="ArrayList全局变量"><a href="#ArrayList全局变量" class="headerlink" title="ArrayList全局变量"></a>ArrayList全局变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 默认的数组初始化大小为10</span><br><span class="line">private static final int DEFAULT_CAPACITY &#x3D; 10;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用于空实例的共享空数组实例</span><br><span class="line">private static final Object[] EMPTY_ELEMENTDATA &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用于默认大小为空的共享数组的实例。我们将其与空实例的共享空数组实例分开来，以了解添加第一个元素时要膨胀多少。</span><br><span class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 实际存放数据的数组</span><br><span class="line">transient Object[] elementData; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; arrayList的长度</span><br><span class="line">private int size;</span><br></pre></td></tr></table></figure><h3 id="ArrayList三个构造器"><a href="#ArrayList三个构造器" class="headerlink" title="ArrayList三个构造器"></a>ArrayList三个构造器</h3><p>1.传入创建ArrayList大小为initialCapacity的有参构造器，创建一个指定大小的数组<br>         创建大小 initialCapacity &gt; 0,创建initialCapacity大小的ArrayList<br>         创建大小 initialCapacity = 0,创建初始化大小为10的ArrayList<br>         创建大小 initialCapacity &lt; 0,抛异常不支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">       if (initialCapacity &gt; 0) &#123;</span><br><span class="line">           this.elementData &#x3D; new Object[initialCapacity];</span><br><span class="line">       &#125; else if (initialCapacity &#x3D;&#x3D; 0) &#123;</span><br><span class="line">           this.elementData &#x3D; EMPTY_ELEMENTDATA;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.无参构造器，创建一个空数组<br>注意：无参初始化并不是在无参构造方法的位置执行的，而是在第一次执行add方法的时候执行了容器大小的设置。所以容器的初始大小应该是0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList() &#123;</span><br><span class="line">    this.elementData &#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.传入一个集合Collection的有参构造器,创建一个与Collection c一样大小的数组，并把c中元素赋值至新数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将c转换成数组</span><br><span class="line">    elementData &#x3D; c.toArray();</span><br><span class="line">    if ((size &#x3D; elementData.length) !&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果数组的类型不是object，转为object类型</span><br><span class="line">        if (elementData.getClass() !&#x3D; Object[].class)</span><br><span class="line">            elementData &#x3D; Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 指向一个空数组</span><br><span class="line">        this.elementData &#x3D; EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="arraycopy-方法：将原数组赋值到新创建的数组中（由于ArrayLits底层都会用到arraycopy方法，这里我提前说明一下）"><a href="#arraycopy-方法：将原数组赋值到新创建的数组中（由于ArrayLits底层都会用到arraycopy方法，这里我提前说明一下）" class="headerlink" title="arraycopy()方法：将原数组赋值到新创建的数组中（由于ArrayLits底层都会用到arraycopy方法，这里我提前说明一下）"></a>arraycopy()方法：将原数组赋值到新创建的数组中（由于ArrayLits底层都会用到arraycopy方法，这里我提前说明一下）</h3><p>　　src：原数组</p><p>　　srcPos：原数组中开始复制的位置</p><p>　　dest：目标数组</p><p>　　destPos：目标数组存放的位置，即从原数组的复制过来的元素从这个位置开始存放数据</p><p>　　length：复制数组的长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static native void arraycopy(Object src,  int  srcPos,</span><br><span class="line">                                    Object dest, int destPos,</span><br><span class="line">                                    int length);</span><br></pre></td></tr></table></figure><h3 id="add-添加元素"><a href="#add-添加元素" class="headerlink" title="add()添加元素"></a>add()添加元素</h3><p>JDK源码中ArrayListd添加一个元素提供了2个add()方法，分别是添加在ArrayList末尾和在具体某个下标位置添加元素。ArrayList在添加元素时会检查当前数组是否已经满了，如果满了则会进行1.5倍扩容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * add方法1：ArrayList末尾添加一个元素</span><br><span class="line"> * @param e 添加的元素</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    &#x2F;&#x2F; 添加元素时,判断数组大小是否越界，越界则需要扩容</span><br><span class="line">    ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!</span><br><span class="line">    elementData[size++] &#x3D; e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * add方法2，在某个下标位置添加元素</span><br><span class="line"> * @param index 下标位置</span><br><span class="line"> * @param element 添加的元素</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    &#x2F;&#x2F; 检查下标是否在数组范围内</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 添加元素时,判断数组大小是否越界，越界则需要扩容</span><br><span class="line">    ensureCapacityInternal(size + 1);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 1.从index位置开始复制原数组elementData到最后一个元素</span><br><span class="line">    &#x2F;&#x2F; 2.copy至原数组elementData的index+1的位置开始（size - index）个元素，也就是后面所有元素</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">                     size - index);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 给index位置赋值新添加元素</span><br><span class="line">    elementData[index] &#x3D; element;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; arrayList长度+1</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList在添加元素时动态扩容：<br>ensureCapacityInternal是ArrayLlist比较核心的一个方法，用于数组大小不够时进行扩容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    &#x2F;&#x2F; 计算添加元素后的新数组容量，若新容量导致数组越界则扩容</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    &#x2F;&#x2F; 修改的次数，添加一次修改次数+1。用于快速失败迭代器（和列表迭代器）</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果当前数组长度不满足于最小所需新容量，则扩容</span><br><span class="line">    if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    &#x2F;&#x2F; 扩容原数组大小的1.5倍</span><br><span class="line">    int oldCapacity &#x3D; elementData.length;</span><br><span class="line">    int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity &#x3D; minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity &#x3D; hugeCapacity(minCapacity);</span><br><span class="line">    &#x2F;&#x2F; minCapacity is usually close to size, so this is a win:</span><br><span class="line">    &#x2F;&#x2F; 以新容量大小，创建新的数组。并把原数组元素拷贝至新数组</span><br><span class="line">    elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;*</span><br><span class="line"> *计算添加元素后的新数组容量</span><br><span class="line"> *若当前数组为空，容量为默认数组大小10和minCapacity最大的一个</span><br><span class="line"> *若当前数组不为空，容量为minCapacity</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;</span><br><span class="line">    if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        return Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    return minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="get-取得元素"><a href="#get-取得元素" class="headerlink" title="get()取得元素"></a>get()取得元素</h3><p>get()：直接用数组下标取得，所以ArrayList查询速度比较快</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 取得一个元素</span><br><span class="line"> * @param index 取得元素下标</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    return elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove-删除元素"><a href="#remove-删除元素" class="headerlink" title="remove()删除元素"></a>remove()删除元素</h3><p>JDK提供2个移除元素的方法，分别是以下标或元素来移除元素。<br>具体移除都是先移除指定位置的元素,然后将该元素之后的元素集体前移一位。如果这个元素位置十分靠前，而数组长度又很大，此时就会极大的耗费性能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 移除一个元素</span><br><span class="line"> * @param index 待移除元素下标</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">    &#x2F;&#x2F; 校验待移除元素下标是否在数组范围内</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 操作计数+1</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue &#x3D; elementData(index);</span><br><span class="line"></span><br><span class="line">    int numMoved &#x3D; size - index - 1;</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        &#x2F;&#x2F; 1.复制elementData数组从（index+1）位置开始的元素，</span><br><span class="line">        &#x2F;&#x2F; 2.把复制的元素从index位置开始，拷贝numMoved个元素至elementData，也就是（index+1）位置后所有元素</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] &#x3D; null; &#x2F;&#x2F; clear to let GC do its work</span><br><span class="line"></span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#x2F;**</span><br><span class="line"> * 移除一个元素</span><br><span class="line"> * @param index 待移除元素</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">        for (int index &#x3D; 0; index &lt; size; index++)</span><br><span class="line">            if (elementData[index] &#x3D;&#x3D; null) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int index &#x3D; 0; index &lt; size; index++)</span><br><span class="line">            if (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clone-克隆：拷贝一个ArrayList"><a href="#clone-克隆：拷贝一个ArrayList" class="headerlink" title="clone()克隆：拷贝一个ArrayList"></a>clone()克隆：拷贝一个ArrayList</h3><p><strong>注意</strong>：ArrayList的clone()是浅拷贝<br><strong>浅拷贝</strong>：被复制对象的任何变量都含有和原来的对象相同的值，而任何的对其他对象的引用仍然指向原来的对象。对拷贝后的引用的修改，还能影响原来的对象。<br><strong>深拷贝</strong>：把要复制的对象所引用的对象都复制了一遍，对现在对象的修改不会影响原有的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 克隆：ArrayList是浅拷贝，拷贝一个List</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public Object clone() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ArrayList&lt;?&gt; v &#x3D; (ArrayList&lt;?&gt;) super.clone();</span><br><span class="line">        v.elementData &#x3D; Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount &#x3D; 0;</span><br><span class="line">        return v;</span><br><span class="line">    &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">        &#x2F;&#x2F; this shouldn&#39;t happen, since we are Cloneable</span><br><span class="line">        throw new InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ArrayList三种遍历方式"><a href="#ArrayList三种遍历方式" class="headerlink" title="ArrayList三种遍历方式"></a>ArrayList三种遍历方式</h2><p>（1）随机访问，通过索引值去遍历。由于ArrayList实现了RandomAccess接口，它支持通过索引值去随机访问元素。（索引取数据，效率最高）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）for循环遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (Object str : list) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）迭代器访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator &#x3D; list.iterator();</span><br><span class="line">while (iterator.hasNext())&#123;</span><br><span class="line">    String str &#x3D; iterator.next();</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>ArrayList的元素有序可重复</li><li>ArrayList底层的操作都是基于数组的操作</li><li>ArrayList查询快，增删慢</li><li>ArrayList线程不安全</li><li>ArrayList每次扩容1.5倍</li><li>ArrayList允许存放null</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;
&lt;h2 id=&quot;ArrayList概述&quot;&gt;&lt;a href=&quot;#ArrayList概述&quot; class=&quot;headerlink&quot; title=&quot;ArrayList概述&quot;&gt;&lt;/a&gt;ArrayList概述&lt;/h2&gt;&lt;p&gt;ArrayList：是一个可以动态改变大小</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JDK源码深入学习之LinkedList</title>
    <link href="http://example.com/2020/10/15/JDK%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8BLinkedList/"/>
    <id>http://example.com/2020/10/15/JDK%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8BLinkedList/</id>
    <published>2020-10-15T07:26:46.673Z</published>
    <updated>2020-10-15T07:48:13.244Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="LinkedList概述"><a href="#LinkedList概述" class="headerlink" title="LinkedList概述"></a>LinkedList概述</h2><p>LinkedList：链表实现的线性表（双链表）<br>LinkedList：有序可重复<br>LinkedList：可以为null<br>LinkedList：查询慢，增删快<br>LinkedList：线程不安全<br>LinkedList：实现了栈和队列的操作方法，因此也可以作为栈、队列和双端队列来使用<br>LinkedList：继承自AbstractSequentialList，实现了List，Deque，Cloneable，Serializable接口<br><img src="https://img-blog.csdnimg.cn/20200703113943789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="LinkedList源码解读"><a href="#LinkedList源码解读" class="headerlink" title="LinkedList源码解读"></a>LinkedList源码解读</h2><p><strong>1.LinkedList定义</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedList&lt;E&gt;</span><br><span class="line">    extends AbstractSequentialList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><p><strong>2.LinkedList定义的变量</strong><br>Node类定义：<br><img src="https://img-blog.csdnimg.cn/2020070311542881.png" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;链表大小</span><br><span class="line">    transient int size &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 链表的头节点</span><br><span class="line">    transient Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 链表的尾节点</span><br><span class="line">    transient Node&lt;E&gt; last;</span><br><span class="line">   </span><br><span class="line">  private static class Node&lt;E&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 当前结点</span><br><span class="line">    E item;</span><br><span class="line">    &#x2F;&#x2F; 下一结点</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    &#x2F;&#x2F; 上一结点</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        this.item &#x3D; element;</span><br><span class="line">        this.next &#x3D; next;</span><br><span class="line">        this.prev &#x3D; prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.构造器</strong><br>LinkedList提供2个构造器，分别是无参构造和创建指定集合的构造器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 无参构造器</span><br><span class="line">public LinkedList() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 指定创建Collection c的有参构造器</span><br><span class="line">public LinkedList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    this();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.增加元素的方法</strong><br>addFirst()：链表头添加一个元素<br>addLast()：链表尾添加一个元素<br>代码实现都类似，这次分析一个链表尾添加元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 链表尾添加一个元素</span><br><span class="line">public void addLast(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;**</span><br><span class="line">  * 在末尾添加元素</span><br><span class="line">  * @param e</span><br><span class="line"> *&#x2F;</span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    &#x2F;&#x2F; 最后一个节点赋值给l，暂存</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建新的节点e,指向前面节点l，指向后面节点为null</span><br><span class="line">    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 新节点赋值给最后一个节点</span><br><span class="line">    last &#x3D; newNode;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果当前是空list，新节点则为第一个节点</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        first &#x3D; newNode;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当前不为空list，则把当前最后节点的下一节点指向新节点</span><br><span class="line">    else</span><br><span class="line">        l.next &#x3D; newNode;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; list长度+1</span><br><span class="line">    size++;</span><br><span class="line">    &#x2F;&#x2F; 操作计数+1</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5.删除元素的方法remove()</strong><br>删除元素会遍历整个链表，比较耗费性能，效率较低</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 删除元素</span><br><span class="line"> * @param o</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    &#x2F;&#x2F; 从头结点开始遍历，查找需要删除的结点</span><br><span class="line">    if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">            if (x.item &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; 删除结点</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">            if (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 删除某个元素</span><br><span class="line"> *&#x2F;</span><br><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">    &#x2F;&#x2F; 当前结点元素</span><br><span class="line">    final E element &#x3D; x.item;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当前结点下一结点</span><br><span class="line">    final Node&lt;E&gt; next &#x3D; x.next;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当前结点上一结点</span><br><span class="line">    final Node&lt;E&gt; prev &#x3D; x.prev;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当前结点为首结点，删除当前结点后，此时首结点就是下一节点</span><br><span class="line">    if (prev &#x3D;&#x3D; null) &#123;</span><br><span class="line">        first &#x3D; next;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 当前结点不为首结点，删除当前结点后，上一结点指向的下一结点为当前结点的下一结点</span><br><span class="line">        prev.next &#x3D; next;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 当前结点下一结点赋为null</span><br><span class="line">        x.prev &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当前结点为尾结点,删除当前节点后，设置尾结点为当前结点的前一结点</span><br><span class="line">    if (next &#x3D;&#x3D; null) &#123;</span><br><span class="line">        last &#x3D; prev;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 当前结点不为尾结点，删除当前结点后，当前结点的下一结点对前一结点的指向  改为 当前结点的前一结点</span><br><span class="line">        next.prev &#x3D; prev;</span><br><span class="line">        &#x2F;&#x2F; 当前结点下一结点赋为null</span><br><span class="line">        x.next &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当前结点元素赋为null</span><br><span class="line">    x.item &#x3D; null;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; list长度-1</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 操作次数+1</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6.取得一个元素get()方法</strong><br>获取元素采用简单二分法遍历数组，也会耗费性能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line">  * 获取一个元素</span><br><span class="line">  * @param index 元素下标</span><br><span class="line">  * @return</span><br><span class="line">  *&#x2F;</span><br><span class="line"> public E get(int index) &#123;</span><br><span class="line">     &#x2F;&#x2F; 检查下标是否越界</span><br><span class="line">     checkElementIndex(index);</span><br><span class="line">     return node(index).item;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line">  * 采用简单二分法取得某个元素</span><br><span class="line">  * @param index</span><br><span class="line">  * @return</span><br><span class="line">  *&#x2F;</span><br><span class="line"> Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">     &#x2F;&#x2F; size &gt;&gt; 1等价于size&#x2F;2，这里判断取的元素在list前半段</span><br><span class="line">     if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">         &#x2F;&#x2F; 从前半段遍历取元素</span><br><span class="line">         Node&lt;E&gt; x &#x3D; first;</span><br><span class="line">         for (int i &#x3D; 0; i &lt; index; i++)</span><br><span class="line">             x &#x3D; x.next;</span><br><span class="line">         return x;</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         &#x2F;&#x2F; 取的元素在list后半段</span><br><span class="line">         &#x2F;&#x2F; 从后半段遍历取元素</span><br><span class="line">         Node&lt;E&gt; x &#x3D; last;</span><br><span class="line">         for (int i &#x3D; size - 1; i &gt; index; i--)</span><br><span class="line">             x &#x3D; x.prev;</span><br><span class="line">         return x;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="总结LinkedList和ArralList性能差异"><a href="#总结LinkedList和ArralList性能差异" class="headerlink" title="总结LinkedList和ArralList性能差异"></a>总结LinkedList和ArralList性能差异</h2><p>1.LinkedList在插入和删除的时候，寻址会损耗性能，但是只需要改变前后Node的引用地址就可以实现。LinkedList插入和删除效率比较稳定。<br>ArralList插入或删除时涉及数组的移动开销，越靠后越快。但是他还存在扩容的情况，扩容也会增大开销。<br>结论：<br>（1）通常情况，插入和删除性能LinkedList优于ArralList<br>（2）如果确定插入或删除元素的位置在前半段，用LinkedList<br>（3）如果确定插入或删除元素的位置在后半段，越靠后越可以考虑使用ArraList</p><p>2.LinkedList在查询上会遍历数组，ArralList直接从下标取元素<br>结论：LinkedList查询性能比ArralList低</p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;
&lt;h2 id=&quot;LinkedList概述&quot;&gt;&lt;a href=&quot;#LinkedList概述&quot; class=&quot;headerlink&quot; title=&quot;LinkedList概述&quot;&gt;&lt;/a&gt;LinkedList概述&lt;/h2&gt;&lt;p&gt;LinkedList：链表实现的线</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JDK源码深入学习之Vector</title>
    <link href="http://example.com/2020/10/15/JDK%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8BVector/"/>
    <id>http://example.com/2020/10/15/JDK%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8BVector/</id>
    <published>2020-10-15T07:26:46.672Z</published>
    <updated>2020-10-15T07:47:54.003Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="Vector概述"><a href="#Vector概述" class="headerlink" title="Vector概述"></a>Vector概述</h2><p>1.Vector是一个矢量队列，底层基于数组实现<br>2.Vector继承于AbstractList，实现了List, RandomAccess, Cloneable这些接口<br>3.Vector 实现了Cloneable接口，即实现clone()函数。它能被克隆。<br>4.Vector里面的元素都是有序可重复的<br>5.Vector 是线程安全的，但也导致了性能要低于ArrayList</p><p><strong>由于Vector与ArrayList极其的相似，这里做一个对比</strong>：<a href="https://blog.csdn.net/qq_38425803/article/details/107086438">ArrayList源码解读</a><br><strong>相同点</strong>：<br>1.底层都是数组<br>2.增删查的操作基本类似<br>3.初始长度都为10<br>4.继承类和实现的接口相同<br><strong>不同点</strong>：<br>1.Vector中方法都加了synchronized关键字保证线程安全，ArralList线程不安全<br>2.Vector新增capacityIncrement容量增长因子参数，用于扩容机制。capacityIncrement&gt;0，扩容至（原数组size+capacityIncrement）大小<br>3.Vector扩容机制增长1倍（capacityIncrement==0），ArrayList扩容1.5倍<br>4.Vector变量用protected修饰，ArrayList用的private修饰<br>Vector类图：<br><img src="https://img-blog.csdnimg.cn/20200706110821612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="Vector源码解读"><a href="#Vector源码解读" class="headerlink" title="Vector源码解读"></a>Vector源码解读</h2><p>1.Vector定义（与ArrayList一样）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Vector&lt;E&gt;</span><br><span class="line">    extends AbstractList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><p>2.Vector定义的变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Vector实际存放数据的数组</span><br><span class="line">protected Object[] elementData;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 数组大小</span><br><span class="line">protected int elementCount;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 容量增长系数</span><br><span class="line">protected int capacityIncrement;</span><br></pre></td></tr></table></figure><p>3.Vector构造器<br>（1）指定初始化数组大小和容量增长系数的构造器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Vector(int initialCapacity, int capacityIncrement) &#123;</span><br><span class="line">    super();</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    this.elementData &#x3D; new Object[initialCapacity];</span><br><span class="line">    this.capacityIncrement &#x3D; capacityIncrement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）指定初始化数组大小和容量增长系数为0的构造器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Vector(int initialCapacity) &#123;</span><br><span class="line">    this(initialCapacity, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）指定默认构造数组大小为10，容量增长系数为0的构造器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Vector() &#123;</span><br><span class="line">    this(10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）指定集合的构造器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Vector(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    elementData &#x3D; c.toArray();</span><br><span class="line">    elementCount &#x3D; elementData.length;</span><br><span class="line">    &#x2F;&#x2F; c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br><span class="line">    if (elementData.getClass() !&#x3D; Object[].class)</span><br><span class="line">        elementData &#x3D; Arrays.copyOf(elementData, elementCount, Object[].class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.添加一个元素add()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加一个元素</span><br><span class="line">public synchronized boolean add(E e) &#123;</span><br><span class="line">    &#x2F;&#x2F; 操作计数+1</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 判断是否扩容，需扩容则扩容</span><br><span class="line">    ensureCapacityHelper(elementCount + 1);</span><br><span class="line">    elementData[elementCount++] &#x3D; e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 判断是否扩容，需扩容则扩容</span><br><span class="line">private void ensureCapacityHelper(int minCapacity) &#123;</span><br><span class="line">    if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        &#x2F;&#x2F; 扩容</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;扩容</span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    &#x2F;&#x2F; 原数组大小</span><br><span class="line">    int oldCapacity &#x3D; elementData.length;</span><br><span class="line">    &#x2F;* 新数组大小</span><br><span class="line">    当Vector的容量不足以容纳当前的全部元素，增加容量大小。</span><br><span class="line">    若容量增长因子capacityIncrement &gt; 0,数组扩容增加capacityIncrement个长度</span><br><span class="line">    若容量增长因子capacityIncrement &lt;&#x3D; 0,数组扩容增加1倍</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int newCapacity &#x3D; oldCapacity + ((capacityIncrement &gt; 0) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity &#x3D; minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity &#x3D; hugeCapacity(minCapacity);</span><br><span class="line">    elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.删除一个元素方法remove()<br>JDK提供2个remove移除方法，分别是根据元素移除和根据下标移除。<br>根据元素移除元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 移除某个元素</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    return removeElement(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public synchronized boolean removeElement(Object obj) &#123;</span><br><span class="line">    &#x2F;&#x2F; 操作计数+1</span><br><span class="line">    modCount++;</span><br><span class="line">    &#x2F;&#x2F; 取得移除元素的下标位置</span><br><span class="line">    int i &#x3D; indexOf(obj);</span><br><span class="line">    if (i &gt;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; 根据下标位置移除元素</span><br><span class="line">        removeElementAt(i);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public synchronized void removeElementAt(int index) &#123;</span><br><span class="line">    &#x2F;&#x2F; 操作计数+1</span><br><span class="line">    modCount++;</span><br><span class="line">    &#x2F;&#x2F; 判断数组下标是否越界</span><br><span class="line">    if (index &gt;&#x3D; elementCount) &#123;</span><br><span class="line">        throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;&#x3D; &quot; +</span><br><span class="line">                                                 elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (index &lt; 0) &#123;</span><br><span class="line">        throw new ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 把待移除元素后面所有的元素向前移动一位</span><br><span class="line">    int j &#x3D; elementCount - index - 1;</span><br><span class="line">    if (j &gt; 0) &#123;</span><br><span class="line">        System.arraycopy(elementData, index + 1, elementData, index, j);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 数组容量-1</span><br><span class="line">    elementCount--;</span><br><span class="line">    &#x2F;&#x2F; 清空原数组最后一个位置元素为null</span><br><span class="line">    elementData[elementCount] &#x3D; null; &#x2F;* to let gc do its work *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据下标移除元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 根据下标移除某个元素</span><br><span class="line">public synchronized E remove(int index) &#123;</span><br><span class="line">    &#x2F;&#x2F; 操作计数+1</span><br><span class="line">    modCount++;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 判断下标是否越界</span><br><span class="line">    if (index &gt;&#x3D; elementCount)</span><br><span class="line">        throw new ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 根据下标取得某个元素</span><br><span class="line">    E oldValue &#x3D; elementData(index);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 待移除元素后面的所有元素向前移动一个位置</span><br><span class="line">    int numMoved &#x3D; elementCount - index - 1;</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 清除最后一个元素赋值为null，数组大小-1</span><br><span class="line">    elementData[--elementCount] &#x3D; null; &#x2F;&#x2F; Let gc do its work</span><br><span class="line"></span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 根据下标取得元素</span><br><span class="line">E elementData(int index) &#123;</span><br><span class="line">    return (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.取得一个元素get()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 根据下标取得元素</span><br><span class="line">E elementData(int index) &#123;</span><br><span class="line">    return (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vector遍历方式"><a href="#Vector遍历方式" class="headerlink" title="Vector遍历方式"></a>Vector遍历方式</h2><p>1.迭代器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Iterator iterator &#x3D; vector.iterator();</span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.随机访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer value &#x3D; null;</span><br><span class="line">int size &#x3D; vector.size();</span><br><span class="line">for (int i&#x3D;0; i&lt;size; i++) &#123;</span><br><span class="line">    value &#x3D; (Integer)vector.get(i);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.java 8新特性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector.forEach(a -&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure><p>4.foreach循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer value &#x3D; null;</span><br><span class="line">for (Integer integ:vec) &#123;</span><br><span class="line">    value &#x3D; integ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.Enumeration遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer value &#x3D; null;</span><br><span class="line">Enumeration enu &#x3D; vec.elements();</span><br><span class="line">while (enu.hasMoreElements()) &#123;</span><br><span class="line">    value &#x3D; (Integer)enu.nextElement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vector所有API"><a href="#Vector所有API" class="headerlink" title="Vector所有API"></a>Vector所有API</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">synchronized boolean        add(E object)</span><br><span class="line">             void           add(int location, E object)</span><br><span class="line">synchronized boolean        addAll(Collection&lt;? extends E&gt; collection)</span><br><span class="line">synchronized boolean        addAll(int location, Collection&lt;? extends E&gt; collection)</span><br><span class="line">synchronized void           addElement(E object)</span><br><span class="line">synchronized int            capacity()</span><br><span class="line">             void           clear()</span><br><span class="line">synchronized Object         clone()</span><br><span class="line">             boolean        contains(Object object)</span><br><span class="line">synchronized boolean        containsAll(Collection&lt;?&gt; collection)</span><br><span class="line">synchronized void           copyInto(Object[] elements)</span><br><span class="line">synchronized E              elementAt(int location)</span><br><span class="line">             Enumeration&lt;E&gt; elements()</span><br><span class="line">synchronized void           ensureCapacity(int minimumCapacity)</span><br><span class="line">synchronized boolean        equals(Object object)</span><br><span class="line">synchronized E              firstElement()</span><br><span class="line">             E              get(int location)</span><br><span class="line">synchronized int            hashCode()</span><br><span class="line">synchronized int            indexOf(Object object, int location)</span><br><span class="line">             int            indexOf(Object object)</span><br><span class="line">synchronized void           insertElementAt(E object, int location)</span><br><span class="line">synchronized boolean        isEmpty()</span><br><span class="line">synchronized E              lastElement()</span><br><span class="line">synchronized int            lastIndexOf(Object object, int location)</span><br><span class="line">synchronized int            lastIndexOf(Object object)</span><br><span class="line">synchronized E              remove(int location)</span><br><span class="line">             boolean        remove(Object object)</span><br><span class="line">synchronized boolean        removeAll(Collection&lt;?&gt; collection)</span><br><span class="line">synchronized void           removeAllElements()</span><br><span class="line">synchronized boolean        removeElement(Object object)</span><br><span class="line">synchronized void           removeElementAt(int location)</span><br><span class="line">synchronized boolean        retainAll(Collection&lt;?&gt; collection)</span><br><span class="line">synchronized E              set(int location, E object)</span><br><span class="line">synchronized void           setElementAt(E object, int location)</span><br><span class="line">synchronized void           setSize(int length)</span><br><span class="line">synchronized int            size()</span><br><span class="line">synchronized List&lt;E&gt;        subList(int start, int end)</span><br><span class="line">synchronized &lt;T&gt; T[]        toArray(T[] contents)</span><br><span class="line">synchronized Object[]       toArray()</span><br><span class="line">synchronized String         toString()</span><br><span class="line">synchronized void           trimToSize()</span><br></pre></td></tr></table></figure><p>参考博文：<br>1.<a href="https://www.cnblogs.com/skywang12345/p/3308833.html">Java 集合系列06之 Vector详细介绍(源码解析)和使用示例</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;
&lt;h2 id=&quot;Vector概述&quot;&gt;&lt;a href=&quot;#Vector概述&quot; class=&quot;headerlink&quot; title=&quot;Vector概述&quot;&gt;&lt;/a&gt;Vector概述&lt;/h2&gt;&lt;p&gt;1.Vector是一个矢量队列，底层基于数组实现&lt;br&gt;2.Vec</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JDK源码深入学习之HashSet</title>
    <link href="http://example.com/2020/10/15/JDK%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8BHashSet/"/>
    <id>http://example.com/2020/10/15/JDK%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8BHashSet/</id>
    <published>2020-10-15T07:26:46.671Z</published>
    <updated>2020-10-15T07:47:35.467Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="HashSet概述"><a href="#HashSet概述" class="headerlink" title="HashSet概述"></a>HashSet概述</h2><p>1.HashSet底层基于HashMap<br>2.HashSet存放的元素无序不重复<br>3.HashSet继承AbstractSet类，实现了set，Cloneable，java.io.Serializable接口<br>4.HashSet线程不安全<br>类图：<br><img src="https://img-blog.csdnimg.cn/20200706150703365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="HashSet源码解读"><a href="#HashSet源码解读" class="headerlink" title="HashSet源码解读"></a>HashSet源码解读</h2><p>1.HashSet成员变量<br> HashSet直接使用HashMap存放数据，因HashMap的Key必须唯一，所以可以将我们需要存放的数据放到Key保证不重复，而所有的value对应一个内部的对象PRESENT</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 实际存放数据的hashmap</span><br><span class="line">private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; hashmap的value值</span><br><span class="line">private static final Object PRESENT &#x3D; new Object();</span><br></pre></td></tr></table></figure><p>2.HashSet构造器<br>（1）无参构造器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 无参构造器</span><br><span class="line">public HashSet() &#123;</span><br><span class="line">    map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）指定一个集合的构造器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 指定一个集合的有参构造器</span><br><span class="line">public HashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    map &#x3D; new HashMap&lt;&gt;(Math.max((int) (c.size()&#x2F;.75f) + 1, 16));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）指定容量和加载因子的构造器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 指定容量和加载因子的构造器</span><br><span class="line">public HashSet(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    map &#x3D; new HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）指定初始容量的构造器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建initialCapacity大小的HashSet</span><br><span class="line">public HashSet(int initialCapacity) &#123;</span><br><span class="line">    map &#x3D; new HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.添加一个元素add()方法<br>■ 往HashSet中添加元素，就是添加一个HashMap存放对应key，value<br>■ HashMap中的key实际就是要添加的元素，value对应一个内部的对象PRESENT<br>■ HashMap中的key不能重复，因此HashSet元素不重复<br>■ HashMap第一次添加成功会返回null，再次插入同样key的元素，会用新的value替换原来的旧的value，并且返回旧的value</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    return map.put(e, PRESENT)&#x3D;&#x3D;null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.移除一个元素remove()<br>■ HashSet删除元素，调用的HashMap的remove()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    return map.remove(o)&#x3D;&#x3D;PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.迭代器取得元素<br>■ HashSet没有get方法，采用迭代器遍历获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return map.keySet().iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.判断是否包含某个元素<br>■ 用HashMap的containsKey(key)方法判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">    return map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>■ HashSet底层是HashMap，HashMap的key存放元素，value存放内部的对象PRESENT<br>■ HashSet以HashMap不能存储重复的Key来实现元素不重复<br>■ HashSet以HashMap的key是基于hashcode存储来保证无序<br>■ HashSet线程不安全</p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;
&lt;h2 id=&quot;HashSet概述&quot;&gt;&lt;a href=&quot;#HashSet概述&quot; class=&quot;headerlink&quot; title=&quot;HashSet概述&quot;&gt;&lt;/a&gt;HashSet概述&lt;/h2&gt;&lt;p&gt;1.HashSet底层基于HashMap&lt;br&gt;2.Has</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Maven_Error_(7, 17) java_ 程序包org.junit不存在，包已引入却报类找不到（不止junit类）</title>
    <link href="http://example.com/2020/10/15/Maven_Error_(7,%2017)%20java_%20%E7%A8%8B%E5%BA%8F%E5%8C%85org.junit%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%8C%85%E5%B7%B2%E5%BC%95%E5%85%A5%E5%8D%B4%E6%8A%A5%E7%B1%BB%E6%89%BE%E4%B8%8D%E5%88%B0%EF%BC%88%E4%B8%8D%E6%AD%A2junit%E7%B1%BB%EF%BC%89/"/>
    <id>http://example.com/2020/10/15/Maven_Error_(7,%2017)%20java_%20%E7%A8%8B%E5%BA%8F%E5%8C%85org.junit%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%8C%85%E5%B7%B2%E5%BC%95%E5%85%A5%E5%8D%B4%E6%8A%A5%E7%B1%BB%E6%89%BE%E4%B8%8D%E5%88%B0%EF%BC%88%E4%B8%8D%E6%AD%A2junit%E7%B1%BB%EF%BC%89/</id>
    <published>2020-10-15T07:26:46.671Z</published>
    <updated>2020-10-15T07:47:14.116Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Maven错误"><a href="#Maven错误" class="headerlink" title="Maven错误"></a>Maven错误</h2><p>描述：maven仓库有junit包，idea也不报红，运行时却依然报找不到类<br><img src="https://img-blog.csdnimg.cn/20200708155257801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><p>修改maven的配置，Build Tools—Maven—Runner：勾选：Deletegate IDE build/run actions to Maven<br><img src="https://img-blog.csdnimg.cn/20200708155653859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Maven错误&quot;&gt;&lt;a href=&quot;#Maven错误&quot; class=&quot;headerlink&quot; title=&quot;Maven错误&quot;&gt;&lt;/a&gt;Maven错误&lt;/h2&gt;&lt;p&gt;描述：maven仓库有junit包，idea也不报红，运行时却依然报找不到类&lt;br&gt;&lt;img src</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Oracle存储过程常用字符串处理函数整理</title>
    <link href="http://example.com/2020/10/15/Oracle%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/"/>
    <id>http://example.com/2020/10/15/Oracle%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/</id>
    <published>2020-10-15T07:26:46.670Z</published>
    <updated>2020-10-15T07:46:28.739Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><p><strong>1.CHR(x):</strong><br>返回在数据库字符集中与X拥有等价数值的字符。CHR和ASCII是一对反函数。经过CHR转换后的字符再经过ASCII转换又得到了原来的字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin</span><br><span class="line">  -- 打印CHR(73)的值</span><br><span class="line">  dbms_output.put_line(CHR(73));    ——&gt;输出：I</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p><strong>2.replace(String,searchStr，replaceStr)：</strong><br>把string中所有的子字符串searchStr用replaceStr字符串替换，如果没有指定replace_str，所有的string中的子字符串 searchStr都将被删除<br>例：<br>（1）替换字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 替换 aabbcc中aa为zz</span><br><span class="line">select replace(&#39;aabbcc&#39;,&#39;aa&#39;,&#39;zz&#39;) from dual   ——&gt;输出：zzbbcc</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（2）替换多个字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--替换aabbcc中aa为空，则为bbcc，再替换bb为空，则为cc</span><br><span class="line">select replace(replace(&#39;aabbcc&#39;,&#39;aa&#39;,&#39;&#39;),&#39;bb&#39;,&#39;&#39;) from dual   ——&gt;输出：cc</span><br></pre></td></tr></table></figure><p>（3）替换后缀</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regexp_replace(&#39;xxaabbxxccaa&#39;,&#39;aa$&#39;,&#39;&#39;)   ——&gt;输出：xxaabbxxcc</span><br></pre></td></tr></table></figure><p>（4）替换前缀</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regexp_replace(&#39;xxaabbxxccaa&#39;,&#39;^xx&#39;,&#39;&#39;)    ——&gt;输出：aabbxxccaa</span><br></pre></td></tr></table></figure><p><strong>3.UPPER（string）</strong><br>字符串转为大写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPPER(&#39;as231.,&#39;)   ——&gt;输出：AS231.,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>4.CONCAT（string1,string2）:</strong><br>string1拼接string2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONCAT(&#39;aa&#39;,&#39;cbb&#39;)   ——&gt;输出：aacbb</span><br></pre></td></tr></table></figure><p><strong>5.SUBSTR（string,num1,num2）</strong><br>从string字符串的第num1个字符，截取num2个长度的字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSTR(&#39;abcdefg&#39;,3,2)   ——&gt;输出：de</span><br></pre></td></tr></table></figure><p><strong>6.translate(expr, from_strimg, to_string)</strong><br>对expr内容，用to_string中的字符逐一替换from_string 中的字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> translate(&#39;1234567&#39;,&#39;123&#39;,&#39;abc&#39;)   ——&gt;输出：abc4567</span><br><span class="line">translate(&#39;1234567&#39;,&#39;123&#39;,&#39;ab&#39;);     ——&gt;输出：ab4567</span><br><span class="line">translate(&#39;1234567&#39;,&#39;1232&#39;,&#39;a&#39;);      ——&gt;输出：a4567</span><br><span class="line">translate(&#39;1234567&#39;,&#39;1231&#39;,&#39;a&#39;);     ——&gt;输出：a4567</span><br><span class="line">translate(&#39;1234567&#39;,&#39;1231&#39;,&#39;abcd&#39;);    ——&gt;输出：abc4567</span><br></pre></td></tr></table></figure><p><strong>7. INSTR（string1,string2,num1,num2）</strong><br>得到在string1中包含string2的位置<br>num1:从string1中第num1个字符开始查找<br>num2：返回查找后的第num2个字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSTR(&#39;abcdefff&#39;,&#39;bc&#39;)   ——&gt;输出：2</span><br><span class="line">INSTR(&#39;abcdefffbcaaabc&#39;,&#39;b&#39;,4,2)   ——&gt;输出：14.      abcdefffbcaaabc中从第4个字符d开始第二次出现b字符的位置</span><br></pre></td></tr></table></figure><p><strong>8.LENGTH（string） ：返回字符串长度</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;
&lt;p&gt;&lt;strong&gt;1.CHR(x):&lt;/strong&gt;&lt;br&gt;返回在数据库字符集中与X拥有等价数值的字符。CHR和ASCII是一对反函数。经过CHR转换后的字符再经过ASCII转换又得到了原来的字符&lt;/p&gt;
&lt;figure class=&quot;highli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>搭建vue+springboot项目：前后端调通测试（解决跨域问题）</title>
    <link href="http://example.com/2020/10/15/%E6%90%AD%E5%BB%BAvue+springboot%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%89%8D%E5%90%8E%E7%AB%AF%E8%B0%83%E9%80%9A%E6%B5%8B%E8%AF%95%EF%BC%88%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%EF%BC%89/"/>
    <id>http://example.com/2020/10/15/%E6%90%AD%E5%BB%BAvue+springboot%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%89%8D%E5%90%8E%E7%AB%AF%E8%B0%83%E9%80%9A%E6%B5%8B%E8%AF%95%EF%BC%88%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%EF%BC%89/</id>
    <published>2020-10-15T07:26:46.670Z</published>
    <updated>2020-10-15T07:46:49.132Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="搭建Vue"><a href="#搭建Vue" class="headerlink" title="搭建Vue"></a>搭建Vue</h2><h3 id="用cli创建vue项目"><a href="#用cli创建vue项目" class="headerlink" title="用cli创建vue项目"></a>用cli创建vue项目</h3><p><strong>1.安装vue开发环境，这里不作阐述</strong><br>版本号：<br><img src="https://img-blog.csdnimg.cn/2020071008264417.png" alt="在这里插入图片描述"><br><strong>2.安装cli并创建vue项目<br>（1）下载vue脚手架。使用命令：npm install –global vue-cli<br>（2）安装webpack模块打包器：npm install -g webpack<br>（3）使用vue init webpack xxx(项目名)，创建项目</strong><br><img src="https://img-blog.csdnimg.cn/20200709160332793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>部分参数介绍：<br>? Project name TCBVue ：项目名<br>? Project description A Vue.js project  ：项目介绍<br>? Author admin ：作者<br>? Vue build standalone<br>? Install vue-router? Yes ：是否安装vue-router，路由<br>? Use ESLint to lint your code? Yes ： 是否用ESLint作为vue代码规范（按需使用，开发时会校验格式十分麻烦，不想用直接no）<br>? Pick an ESLint preset Standard ：ESLint规范相关<br>? Set up unit tests Yes ：是否安装单元测试<br>? Pick a test runner jest ：test runner<br>? Setup e2e tests with Nightwatch? Yes ： e2e测试<br>? Should we run <code>npm install</code> for you after the project has been created? (recommended) npm ：是否项目创建后执行npm install命令<br><strong>3.使用npm install 命令，安装npm</strong><br><img src="https://img-blog.csdnimg.cn/20200709160035179.png" alt="在这里插入图片描述"><br><strong>4.使用npm run dev命令，启动项目</strong><br><img src="https://img-blog.csdnimg.cn/20200709160303292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>5.浏览器输入<a href="http://localhost:8082/#/%E8%AE%BF%E9%97%AE%EF%BC%8C%E5%A6%82%E4%B8%8B%E7%95%8C%E9%9D%A2%E5%88%99%E5%88%9B%E5%BB%BA%E6%88%90%E5%8A%9F">http://localhost:8082/#/访问，如下界面则创建成功</a></strong><br><img src="https://img-blog.csdnimg.cn/2020070916044882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>6.执行安装命令安装相关包，后续搭建项目使用</strong><br>（1）npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a><br>cnpm：淘宝镜像，国内用于下载依赖包。下载速度较快<br>（2）npm install axios –save-dev ：安装axios包，用于前端发送get，post请求</p><h3 id="idea配置vue项目并启动"><a href="#idea配置vue项目并启动" class="headerlink" title="idea配置vue项目并启动"></a>idea配置vue项目并启动</h3><p>1.idea打开刚刚创建的项目<br>2.配置启动参数<br><img src="https://img-blog.csdnimg.cn/20200709162535386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>debug启动<br><img src="https://img-blog.csdnimg.cn/20200709162719816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="生成的vue项目的运行原理（若想快速搭建直接跳过这节）"><a href="#生成的vue项目的运行原理（若想快速搭建直接跳过这节）" class="headerlink" title="生成的vue项目的运行原理（若想快速搭建直接跳过这节）"></a>生成的vue项目的运行原理（若想快速搭建直接跳过这节）</h3><p>上图：<br><img src="https://img-blog.csdnimg.cn/20200709165816713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>1.执行npm run dev命令启动，找到cli脚手架生成的package.json配置<br>2.去main.js根据id找要实例化的vue：App.vue，对页面进行渲染。此时加载logo.png图片<br>3.App.vue根据router-view找到默认路由路径 “/“<br>4.根据配置的默认路由信息name找到具体的HelloWorld.vue对页面再次渲染。此时渲染图片中的Essential Links等等界面信息<br><img src="https://img-blog.csdnimg.cn/20200709171134957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="搭建springboot项目"><a href="#搭建springboot项目" class="headerlink" title="搭建springboot项目"></a>搭建springboot项目</h2><p>1.用spring initializr创建项目<img src="https://img-blog.csdnimg.cn/20200709171516833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2.配置生成项目的相关信息<br><img src="https://img-blog.csdnimg.cn/20200709171612320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.选择需要依赖的组件，这里选择Spring Web和Thymeleaf风格<br><img src="https://img-blog.csdnimg.cn/20200709171636376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200709171701573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4.新建controller包，这个包下面创建DemoController.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.test.demo.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class DemoController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;testSpringBoot&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public void testSpringBoot() &#123;</span><br><span class="line">        System.out.println(&quot;testSpringBoot&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="前后端联调-解决跨域问题"><a href="#前后端联调-解决跨域问题" class="headerlink" title="前后端联调(解决跨域问题)"></a>前后端联调(解决跨域问题)</h2><p>1.vue前端HelloWorld.vue写一个按钮，点击发送get请求。在export default 里面添加发送请求的方法<br><img src="https://img-blog.csdnimg.cn/20200709172829399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  name: &#39;HelloWorld&#39;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &#39;Welcome to Your Vue.js App&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    aa () &#123;</span><br><span class="line">      console.log(&#39;aasa&#39;)</span><br><span class="line">      this.$axios</span><br><span class="line">        .get(&#39;http:&#x2F;&#x2F;localhost:8080&#x2F;testSpringBoot&#39;)</span><br><span class="line">        .then(response &#x3D;&gt; (this.info &#x3D; response.data))</span><br><span class="line">        .catch(function (error) &#123; &#x2F;&#x2F; 请求失败处理</span><br><span class="line">          console.log(error)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.启动后端springboot项目，注意端口8080<br><img src="https://img-blog.csdnimg.cn/20200710082504978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.启动前端vue项目，注意端口8081<br><img src="https://img-blog.csdnimg.cn/20200709173406566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.点击点击按钮，发送请求。<strong>我们发现这里报错了，意思是后端的端口8080，前端的端口8081，映射不匹配，这是跨域问题</strong><br><img src="https://img-blog.csdnimg.cn/20200709173458354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>4.跨域问题解决（vue 2.9版本，3.0版本在文末做处理）：<br>（1）在config目录下index.js添加proxyTable代理<br><img src="https://img-blog.csdnimg.cn/20200709173958926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">proxyTable: &#123;    &#39;&#x2F;api&#39;:&#123;</span><br><span class="line">    target: &quot;http:&#x2F;&#x2F;127.0.0.1:8080&quot;, &#x2F;&#x2F;请求地址</span><br><span class="line">    changeOrigin: true,  &#x2F;&#x2F;是否跨域</span><br><span class="line">    pathRewrite: &#123;  &#x2F;&#x2F;替换重写</span><br><span class="line">      &#39;^&#x2F;api&#39;: &#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&#125;,</span><br></pre></td></tr></table></figure><p>（2）修改HelloWorld.vue url路径<br><img src="https://img-blog.csdnimg.cn/20200709174034161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>测试：<br>此时就正常了<br>前端页面：console打印了，无报错<br><img src="https://img-blog.csdnimg.cn/20200709174219666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>后端：testSpringBoot也打印了，说明进入了后端<br><img src="https://img-blog.csdnimg.cn/20200709174355467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>vue3.0版本解决跨域问题</strong>（vue2.9和3.0版本配置文件目录发生了变化）：<br>在与package.json同目录下的vue.config.js文件<br>添加devServer配置：<br><img src="https://img-blog.csdnimg.cn/20200710083214497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>或者这种配置proxy代理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      &#39;&#x2F;api&#39;: &#123;</span><br><span class="line">        target: &#39;http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#39;,</span><br><span class="line">        changeOrigin: true,</span><br><span class="line">        ws: true,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          &#39;^&#x2F;api&#39;: &#39;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>参考博文：<a href="https://blog.csdn.net/weixin_42603009/article/details/91477222">https://blog.csdn.net/weixin_42603009/article/details/91477222</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://blog.csdn.net/qq_39081974/article/details/95977342">https://blog.csdn.net/qq_39081974/article/details/95977342</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;
&lt;h2 id=&quot;搭建Vue&quot;&gt;&lt;a href=&quot;#搭建Vue&quot; class=&quot;headerlink&quot; title=&quot;搭建Vue&quot;&gt;&lt;/a&gt;搭建Vue&lt;/h2&gt;&lt;h3 id=&quot;用cli创建vue项目&quot;&gt;&lt;a href=&quot;#用cli创建vue项目&quot; clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Oracle查询用户，表结构，表索引，存储过程，触发器等信息整理</title>
    <link href="http://example.com/2020/10/15/Oracle%E6%9F%A5%E8%AF%A2%E7%94%A8%E6%88%B7%EF%BC%8C%E8%A1%A8%E7%BB%93%E6%9E%84%EF%BC%8C%E8%A1%A8%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%8C%E8%A7%A6%E5%8F%91%E5%99%A8%E7%AD%89%E4%BF%A1%E6%81%AF%E6%95%B4%E7%90%86/"/>
    <id>http://example.com/2020/10/15/Oracle%E6%9F%A5%E8%AF%A2%E7%94%A8%E6%88%B7%EF%BC%8C%E8%A1%A8%E7%BB%93%E6%9E%84%EF%BC%8C%E8%A1%A8%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%8C%E8%A7%A6%E5%8F%91%E5%99%A8%E7%AD%89%E4%BF%A1%E6%81%AF%E6%95%B4%E7%90%86/</id>
    <published>2020-10-15T07:26:46.669Z</published>
    <updated>2020-10-15T07:46:06.276Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><p>1.查询当前登录用户的表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user_tables；</span><br></pre></td></tr></table></figure><p>2.查询scott用户所有表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from all_tables where owner&#x3D;&#39;SCOTT&#39;;</span><br></pre></td></tr></table></figure><p>3.查询当前用户的所有存储过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user_procedures ；</span><br></pre></td></tr></table></figure><p>4.以SYS管理员身份登陆，并授予SCOTT用户debug存储过程权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT DEBUG CONNECT SESSION TO SCOTT</span><br></pre></td></tr></table></figure><p>5.查询存储过程详细信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from all_procedures where object_name&#x3D;&#39;存储过程名字&#39;;</span><br></pre></td></tr></table></figure><p>6.查询当前用户的所有索引 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user_indexes</span><br></pre></td></tr></table></figure><p>7.查询某表创建索引语句<br> index_name：索引名字<br>TS_TIMESTAMP：表名，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT DBMS_METADATA.GET_DDL(&#39;INDEX&#39;, index_name),index_name</span><br><span class="line">                  FROM USER_INDEXES WHERE table_name &#x3D; &#39;TS_TIMESTAMP&#39;</span><br><span class="line">                  AND UNIQUEness &#x3D; &#39;NONUNIQUE&#39;</span><br></pre></td></tr></table></figure><p>8.查询某表的索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from all_indexes  where table_name&#x3D;&#39;表名&#39;;</span><br></pre></td></tr></table></figure><p>9.在数据库系统取得某表的建表语句<br>v_base_table_name_upper为表名，v_base_ddl 为定义的字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DBMS_METADATA.GET_DDL(&#39;TABLE&#39;, v_base_table_name_upper) into v_base_ddl from dual;</span><br></pre></td></tr></table></figure><p><em>10.查询当前用户的触发器</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user_triggers；</span><br></pre></td></tr></table></figure><p>11.查询某表的触发器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from all_triggers where  table_name&#x3D;&#39;表名&#39;;</span><br></pre></td></tr></table></figure><p><em>12.查询当前用户的视图</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select *  from user_views；</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;
&lt;p&gt;1.查询当前登录用户的表&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/t</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Oracle日期处理整理</title>
    <link href="http://example.com/2020/10/15/Oracle%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%B4%E7%90%86/"/>
    <id>http://example.com/2020/10/15/Oracle%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86%E6%95%B4%E7%90%86/</id>
    <published>2020-10-15T07:26:46.668Z</published>
    <updated>2020-10-15T07:45:25.572Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h4 id="1-获取日期元素"><a href="#1-获取日期元素" class="headerlink" title="1.获取日期元素"></a>1.获取日期元素</h4><p>注意：<br>1.hh24写法指24小时，Oracle默认是12小时<br>2.分钟用mi，不要用mm，因为与之前的MM冲突<br>&nbsp;&nbsp;&nbsp; 1-12小时写法  yyyyMMdd24miss（Oracle默认）<br>&nbsp;&nbsp;&nbsp; 1-24小时写法  yyyyMMddHH24miss<br><strong>获取日期元素：</strong><br>select to_char(sysdate,’yyyy-mm-dd hh24:mi:ss’)  from dual;   //日期转化为字符串<br>select to_char(sysdate,’yyyy’)   from dual;   //获取时间的年<br>select to_char(sysdate,’mm’)    from dual;   //获取时间的月<br>select to_char(sysdate,’dd’)     from dual;   //获取时间的日<br>select to_char(sysdate,’hh24’)    from dual;   //获取时间的时<br>select to_char(sysdate,’mi’)     from dual;   //获取时间的分<br>select to_char(sysdate,’ss’)     from dual;   //获取时间的秒</p><p><strong>获取当年/当月哪一周</strong><br>– 获取指定时间为哪一周<br>select to_char(to_date(‘20200805’,’yyyy-mm-dd hh24:mi:ss’),’w’) FROM dual;</p><p>ww:按每年的1月1日为第一周第一天，1月8日为第二周第一天<br>w:与ww功能类似，不过它是按每月的1日为每周第一天，例如1日为当月第一周第一天，8日为第二周第一天<br>iw:自然周，为星期一至星期日算一周，且每年的第一个星期一为第一周</p><p>//查询今年第几周<br>select to_char(sysdate,’ww’) from dual;  //每天第一天为第一周第一天<br>select to_char(sysdate,’iw’) from dual;  //自然周<br>// 查询本月第几周<br>select to_char(sysdate,’w’) from dual;</p><p>select trunc(日期,’d’)+1 from dual; –意周日为一周起始日期<br>select trunc(日期,’iw’) from dual;–意周日为一周结束日期</p><p><strong>时间精确到毫秒用timestamp</strong><br>– 时间精确到毫秒<br>select to_char(systimestamp, ‘yyyy-mm-dd hh24:mi:ss.ff ‘) from dual;<br>select to_timestamp(‘2003-10-2410:48:45.656000’,’yyyy-mm-dd hh24:mi:ssxff’) from dual;<br>select to_char(systimestamp,’yyyy-mm-ddhh24:mi:ssxff’) time1, to_char(current_timestamp) time2 from dual;<br>select to_char(systimestamp, ‘yyyymmddhh24missff’),to_char(systimestamp, ‘yyyymmddhh24miss’),to_char(systimestamp, ‘yyyy-mm-dd hh24:mi:ss.ff ‘) from dual;<br>select substr(to_char(systimestamp, ‘yyyymmddhh24missff’),0,17) from dual;<br>select cast(systimestamp as date)  from dual; </p><h4 id="2-日期转换"><a href="#2-日期转换" class="headerlink" title="2.日期转换"></a>2.日期转换</h4><p>系统当前时间SYSDATE： ‘2020/8/3 16:26:52’；<br>select to_char(SYSDATE,’yyyyMMddHH24miss’) from dual;<br>select to_date(‘20200803140816’,’yyyyMMddHH24miss’) from dual;<br>select to_date(‘2020-08-03 00:00:00’,’yyyy-mm-dd hh24:mi:ss’) FROM dual;</p><h4 id="3-trunc：截断到最接近的日期-单位为天"><a href="#3-trunc：截断到最接近的日期-单位为天" class="headerlink" title="3.trunc：截断到最接近的日期,单位为天"></a>3.trunc：截断到最接近的日期,单位为天</h4><p>select trunc(sysdate, ‘mm’)   from   dual  –    返回当月第一天.<br>select trunc(sysdate,’yy’) from dual  –      返回当年第一天<br>select trunc(sysdate,’dd’) from dual  –返回当前年月日<br>select trunc(sysdate,’yyyy’) from dual  –返回当年第一天<br>select trunc(sysdate,’d’) from dual  –返回当前星期的第一天:星期天<br>select trunc(sysdate, ‘hh’) from dual   –返回当前小时时间<br>select trunc(sysdate, ‘mi’) from dual  –TRUNC()函数没有秒的精确</p><p>select trunc(to_date(last_day(sysdate))) + （8**<strong>60+30）/ (24</strong>60) from dual;–获取当前月最后一天2020/8/31 8:30:00<br>select trunc(sysdate+1) + (8 * 60+30) / (24 * 60) from dual;–获取下一天的8点半日期2020/8/4 8:30:00</p><h4 id="4-日期加减"><a href="#4-日期加减" class="headerlink" title="4.日期加减"></a>4.日期加减</h4><p>加：<br>select sysdate,add_months(sysdate,12) from dual; –加1年<br>select sysdate,add_months(sysdate,1) from dual; –加1月<br>select sysdate,to_char(sysdate+7,’yyyy-mm-dd HH24:MI:SS’) from dual; –加1星期<br>select sysdate,to_char(sysdate+1,’yyyy-mm-dd HH24:MI:SS’) from dual; –加1天<br>select sysdate,to_char(sysdate+1/24,’yyyy-mm-dd HH24:MI:SS’) from dual; –加1小时<br>select sysdate,to_char(sysdate+1/24/60,’yyyy-mm-dd HH24:MI:SS’) from dual; –加1分钟<br>select sysdate,to_char(sysdate+1/24/60/60,’yyyy-mm-dd HH24:MI:SS’) from dual; –加1秒</p><p>减：<br>select sysdate,add_months(sysdate,-12) from dual; –减1年<br>select sysdate,add_months(sysdate,-1) from dual; –减1月<br>select sysdate,to_char(sysdate-7,’yyyy-mm-dd HH24:MI:SS’) from dual; –减1星期<br>select sysdate,to_char(sysdate-1,’yyyy-mm-dd HH24:MI:SS’) from dual; –减1天<br>select sysdate,to_char(sysdate-1/24,’yyyy-mm-dd HH24:MI:SS’) from dual; –减1小时<br>select sysdate,to_char(sysdate-1/24/60,’yyyy-mm-dd HH24:MI:SS’) from dual; –减1分钟<br>select sysdate,to_char(sysdate-1/24/60/60,’yyyy-mm-dd HH24:MI:SS’) from dual; –减1秒</p><h4 id="5-round-返回指定的小数位元数进行四舍五入运算的结果"><a href="#5-round-返回指定的小数位元数进行四舍五入运算的结果" class="headerlink" title="5.round:返回指定的小数位元数进行四舍五入运算的结果"></a>5.round:返回指定的小数位元数进行四舍五入运算的结果</h4><p>select round(123.456, 0) from dual; 回传 123<br>select round(123.456, 1) from dual; 回传 123.5<br>select round(123.456, 2) from dual; 回传 123.46<br>select round(123.456, 3) from dual; 回传 123.456<br>select round(-123.456, 2) from dual; 回传 -123.46</p><h4 id="6-计算时间差"><a href="#6-计算时间差" class="headerlink" title="6.计算时间差"></a>6.计算时间差</h4><p>注:oracle时间差是以天数为单位,所以换算成年月,日<br>select floor(to_number(sysdate-to_date(‘2020-08-03 18:25:03’,’yyyy-mm-dd hh24:mi:ss’))/365) as spanYears from dual        //时间差-年<br>select ceil(moths_between(sysdate-to_date(‘2020-08-03 18:25:03’,’yyyy-mm-dd hh24:mi:ss’))) as spanMonths from dual        //时间差-月<br>select floor(to_number(sysdate-to_date(‘2020-08-03 18:25:03’,’yyyy-mm-dd hh24:mi:ss’))) as spanDays from dual             //时间差-天<br>select floor(to_number(sysdate-to_date(‘2020-08-03 18:25:03’,’yyyy-mm-dd hh24:mi:ss’))*24) as spanHours from dual         //时间差-时<br>select floor(to_number(sysdate-to_date(‘2020-08-03 18:25:03’,’yyyy-mm-dd hh24:mi:ss’)) * 24 * 60) as spanMinutes from dual    //时间差-分<br>select floor(to_number(sysdate-to_date(‘2020-08-03 18:25:03’,’yyyy-mm-dd hh24:mi:ss’)) *  24 * 60 * 60) as spanSeconds from dual //时间差-秒</p><h4 id="7-定时器用到的时间"><a href="#7-定时器用到的时间" class="headerlink" title="7.定时器用到的时间"></a>7.定时器用到的时间</h4><p>1、 每分钟执行</p><p>Interval =&gt; TRUNC(sysdate,’mi’) + 1 / (24*60)</p><p>2、 每天定时执行</p><p>例如：每天的凌晨2点执行</p><p>Interval =&gt; TRUNC(sysdate) + 1 +2 / (24)</p><p>3、 每周定时执行</p><p>例如：每周一凌晨2点执行</p><p>Interval =&gt; TRUNC(next_day(sysdate,2))+2/24 –星期一,一周的第二天</p><p>4、 每月定时执行</p><p>例如：每月1日凌晨2点执行</p><p>Interval =&gt;TRUNC(LAST_DAY(SYSDATE))+1+2/24</p><p>5、 每季度定时执行</p><p>例如每季度的第一天凌晨2点执行</p><p>Interval =&gt; TRUNC(ADD_MONTHS(SYSDATE,3),’Q’) + 2/24</p><p>6、 每半年定时执行</p><p>例如：每年7月1日和1月1日凌晨2点</p><p>Interval =&gt; ADD_MONTHS(trunc(sysdate,’yyyy’),6)+2/24</p><p>7、 每年定时执行</p><p>例如：每年1月1日凌晨2点执行</p><p>Interval =&gt;ADD_MONTHS(trunc(sysdate,’yyyy’),12)+2/24</p><p>荐：<br><a href="https://www.cnblogs.com/sharpest/p/7769625.html">ORACLE日期时间函数大全</a><br><a href="https://www.cnblogs.com/plmm/p/7381538.html">oracle中常用的时间格式转换</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;
&lt;h4 id=&quot;1-获取日期元素&quot;&gt;&lt;a href=&quot;#1-获取日期元素&quot; class=&quot;headerlink&quot; title=&quot;1.获取日期元素&quot;&gt;&lt;/a&gt;1.获取日期元素&lt;/h4&gt;&lt;p&gt;注意：&lt;br&gt;1.hh24写法指24小时，Oracle默认是12小</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>PLSQL如何调试存储过程</title>
    <link href="http://example.com/2020/10/15/PLSQL%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2020/10/15/PLSQL%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</id>
    <published>2020-10-15T07:26:46.668Z</published>
    <updated>2020-10-15T07:45:46.356Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><p><br>转载自：<a href="https://blog.csdn.net/u010191034/article/details/50757208">https://blog.csdn.net/u010191034/article/details/50757208</a><br><br><font color = red size = 4>如侵权，请联系博主，立马删除。谢谢</p><div id="article_content" class="article_content clearfix">            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-211130ba7a.css">                            <div class="htmledit_views" id="content_views"><ol><li>首先在PL/SQL的左侧资源栏中展开Procedures项（图中位置1），然后再其上面的搜索框中（图中位置2）输入存过名称的关键词，按回车键搜索要调试的存过，不停的回车，直到找到想要调试的存过。<br><br><img src="https://img-blog.csdn.net/20160227215621619?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></li><li>找到想要调试的存过，左键单击选中该存过（图中位置1），然后右键单击该存过，从弹出菜单中选择“Test”项（图中位置2）。<br><br><img src="https://img-blog.csdn.net/20160227215633166?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></li><li>单击“Test”后，PL\SQL会打开调试界面，图中位置1的按钮就是开始调试的按钮，在调试之前要填写存过的参数，位置2就是填写参数的地方，如果有多个参数，会有多行参数框，按参数名填写相应的参数即可。<br><img src="https://img-blog.csdn.net/20160227215646869?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></li><li>填写完参数，单击开始调试按钮后，调试的界面会发生一些变化。图中位置1的变化，说明存过已经处于执行状态，别人不能再编译或者执行。位置2的按钮就是执行按钮，单击这个按钮存过会执行完成或者遇到bug跳出，否则是不会停下来的，调试时不会用这个按钮的。位置3的按钮才是关键——单步执行，就是让代码一行一行的执行，位置4的按钮是跳出单步执行，等待下一个指令。<br><br><img src="https://img-blog.csdn.net/20160227215703088?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></li><li>单击“单步执行”，存过开始单步执行。界面中每一次执行的代码会高亮显示（图中位置1），如果想要看某个变量具体的值，就在位置2的地方输入该变量名，然后变量的值会显示在位置3的地方。<br><br><img src="https://img-blog.csdn.net/20160227215717276?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></li><li>调试的时候，每一次单步执行的时候要记一下执行代码的行数，图中位置3的数字就是当前执行代码的行数，就是第几行。如果过程单步执行到某行后，再单步执行的时候，存过就退出，那么错误就在该行的下一行。<br><img src="https://img-blog.csdn.net/20160227215732916?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></li><li>代码执行到24行,在往下执行时，直接转到exception的地方，也就是异常处理的部分。<br><img src="https://img-blog.csdn.net/20160227215746354?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br></li><li>这说明我们代码中的错误在24和25行上，我们打开存过，浏览到24行和25行附近，发现25行和24行使用了两个变量，记住那两个变量。重新开始调试过程。<br><img src="https://img-blog.csdn.net/20160227215800309?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br><p>9. 单步的执行时候把刚才那两个变量名填写到变量查看框，一边观察变量值变化，一边单步执行，执行到24行的时候，发现一个变量已经有值了，而另一个变量的值为null。错误原因明朗了吧？就是变量没有赋值或者初始话，给该变量赋值后存过就不报错了。</p><p><br></p><p><img src="https://img-blog.csdn.net/20160227215813760?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></p><p><br></p><p><br></p></li></ol><p>来自 &lt;<a href="http://jingyan.baidu.com/article/3a2f7c2e144d2826aed61167.html">http://jingyan.baidu.com/article/3a2f7c2e144d2826aed61167.html</a>&gt;&nbsp;<br>                                    </div><div data-report-view="{&quot;mod&quot;:&quot;1585297308_001&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/u010191034/article/details/50757208&quot;,&quot;extend1&quot;:&quot;pc&quot;,&quot;ab&quot;:&quot;new&quot;}"><div></div></div><br>                                </div></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;p&gt;&lt;br&gt;转载自：&lt;a href=&quot;https://blog.csdn.net/u010191034/article/details/50757208&quot;&gt;https://blog.csdn.net/u010191034/article/detail</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Oracle定时器用法详解与案例</title>
    <link href="http://example.com/2020/10/15/Oracle%E5%AE%9A%E6%97%B6%E5%99%A8%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%8E%E6%A1%88%E4%BE%8B/"/>
    <id>http://example.com/2020/10/15/Oracle%E5%AE%9A%E6%97%B6%E5%99%A8%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%8E%E6%A1%88%E4%BE%8B/</id>
    <published>2020-10-15T07:26:46.667Z</published>
    <updated>2020-10-15T07:45:08.564Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="例子：每分钟向表里插入一条数据"><a href="#例子：每分钟向表里插入一条数据" class="headerlink" title="例子：每分钟向表里插入一条数据"></a>例子：每分钟向表里插入一条数据</h2><h4 id="1-创建一个存储过程，插入USER表一条数据"><a href="#1-创建一个存储过程，插入USER表一条数据" class="headerlink" title="1.创建一个存储过程，插入USER表一条数据"></a>1.创建一个存储过程，插入USER表一条数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create or replace procedure AUTO_INSERT_TIMESTAMP AUTHID CURRENT_USER IS;</span><br><span class="line">begin</span><br><span class="line">   &#x2F;&#x2F;插入一条数据</span><br><span class="line">   INSERT INTO USER(&quot;ID&quot;, &quot;USER_ID&quot;, &quot;CERT_NO&quot;, &quot;CERT_NOTAFTER_TIME&quot;, &quot;REMARK&quot;, &quot;STATUS&quot;,  &quot;CREATE_TIME&quot;) </span><br><span class="line">    values(&#39;11111&#39;,&#39;userid&#39;,&#39;certid&#39;,20202222,&#39;REMARK&#39;,1,20201111);</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F;提交</span><br><span class="line">   commit;</span><br><span class="line">end AUTO_INSERT_TIMESTAMP;</span><br></pre></td></tr></table></figure><h4 id="2-创建一个定时器，每分钟触发一次存储过程插入一条数据"><a href="#2-创建一个定时器，每分钟触发一次存储过程插入一条数据" class="headerlink" title="2.创建一个定时器，每分钟触发一次存储过程插入一条数据"></a>2.创建一个定时器，每分钟触发一次存储过程插入一条数据</h4><p>JOB =&gt; job,   自动生成JOB_ID<br>WHAT =&gt; ‘AUTO_INSERT_TIMESTAMP;’,需要执行的存储过程名称或SQL语句<br>NEXT_DATE =&gt; sysdate+3/(24<em>60), 初次执行时间-下一个3分钟<br>INTERVAL =&gt; ‘trunc(sysdate,’’mi’’)+1/(24</em>60)’ 每隔1分钟执行一次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">declare</span><br><span class="line">job number;</span><br><span class="line">BEGIN</span><br><span class="line">DBMS_JOB.SUBMIT( </span><br><span class="line">JOB &#x3D;&gt; job, &#x2F;*自动生成JOB_ID*&#x2F; </span><br><span class="line">WHAT &#x3D;&gt; &#39;AUTO_INSERT_TIMESTAMP;&#39;, &#x2F;*需要执行的存储过程名称或SQL语句*&#x2F; </span><br><span class="line">NEXT_DATE &#x3D;&gt; sysdate+3&#x2F;(24*60), &#x2F;*初次执行时间-下一个3分钟*&#x2F; </span><br><span class="line">INTERVAL &#x3D;&gt; &#39;trunc(sysdate,&#39;&#39;mi&#39;&#39;)+1&#x2F;(24*60)&#39; &#x2F;*每隔1分钟执行一次*&#x2F;</span><br><span class="line">); </span><br><span class="line">commit;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><h4 id="INTERVAL-相关时间处理"><a href="#INTERVAL-相关时间处理" class="headerlink" title="INTERVAL 相关时间处理"></a>INTERVAL 相关时间处理</h4><p>Interval =&gt; trunc(sysdate,’mi’) + 1 / (24*60) ；  –每分钟执行</p><p>Interval =&gt; trunc(sysdate) + 1 +2 / (24)；&nbsp;&nbsp;–每天定时执行：每天的凌晨2点执行</p><p>Interval =&gt; trunc(next_day(sysdate,2))+2/24 &nbsp;&nbsp;–每周定时执行：每周一凌晨2点执行（周一为一周的第二天）</p><p>Interval =&gt;trunc(LAST_DAY(SYSDATE))+1+2/24;&nbsp;–每月定时执行：每月1日凌晨2点执行</p><p>Interval =&gt; trunc(ADD_MONTHS(SYSDATE,3),‘Q’) + 2/24;&nbsp;&nbsp;–每季度定时执行：每季度的第一天凌晨2点执行</p><p>Interval =&gt; ADD_MONTHS(trunc(sysdate,‘yyyy’),6)+2/24;&nbsp;&nbsp;–每半年定时执行：每年7月1日和1月1日凌晨2点</p><p>Interval =&gt;ADD_MONTHS(trunc(sysdate,‘yyyy’),12)+2/24;&nbsp;&nbsp;–每年定时执行：每年1月1日凌晨2点执行</p><h4 id="Job相关处理"><a href="#Job相关处理" class="headerlink" title="Job相关处理"></a>Job相关处理</h4><p>id：下图的JOB字段对应的值，job的id</p><p>dbms_job.remove(id);       –根据id删除某个定时器</p><p>dbms_job.run(id);   –启动定时器   </p><p>dbms_job.broken(id,true)   –true  Y  定时器状态停止  ；false  N  定时器状态运行。数据库存N,Y如下图</p><p>dbms_job.next_date(id,to_date(‘2020-08-03 22:00:00’,’yyyy-mm-dd hh24:mi:ss’))       –修改定时器的下次执行时间</p><p>dbms_job.interval(id,’sysdate+1/24’)  –修改定时器的间隔时间</p><p>dbms_job.what(id,’AUTO_INSERT_TIMESTAMP ;’)     –修改定时器的存储过程</p><h4 id="查询job相关信息"><a href="#查询job相关信息" class="headerlink" title="查询job相关信息"></a>查询job相关信息</h4><p>select * from user_jobs;<br><img src="https://img-blog.csdnimg.cn/20200803190227210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;
&lt;h2 id=&quot;例子：每分钟向表里插入一条数据&quot;&gt;&lt;a href=&quot;#例子：每分钟向表里插入一条数据&quot; class=&quot;headerlink&quot; title=&quot;例子：每分钟向表里插入一条数据&quot;&gt;&lt;/a&gt;例子：每分钟向表里插入一条数据&lt;/h2&gt;&lt;h4 id=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Oracle之静态游标与动态游标</title>
    <link href="http://example.com/2020/10/15/Oracle%E4%B9%8B%E9%9D%99%E6%80%81%E6%B8%B8%E6%A0%87%E4%B8%8E%E5%8A%A8%E6%80%81%E6%B8%B8%E6%A0%87/"/>
    <id>http://example.com/2020/10/15/Oracle%E4%B9%8B%E9%9D%99%E6%80%81%E6%B8%B8%E6%A0%87%E4%B8%8E%E5%8A%A8%E6%80%81%E6%B8%B8%E6%A0%87/</id>
    <published>2020-10-15T07:26:46.666Z</published>
    <updated>2020-10-15T07:44:47.940Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h4 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h4><p>简述：存储过程代码中从表中检索出结果集进行操作交互。</p><h4 id="静态游标和动态游标"><a href="#静态游标和动态游标" class="headerlink" title="静态游标和动态游标"></a>静态游标和动态游标</h4><p>静态游标：程序执行的时候不需要再去解析sql语言，对于sql语句的解析在编译的时候就可以完成<br>动态游标：含有参数，对于sql语句的解析必须要等到参数确定的时候才能完成<br>测试表的BONUS1数据:<br><img src="https://img-blog.csdnimg.cn/20200805192252440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="静态游标demo"><a href="#静态游标demo" class="headerlink" title="静态游标demo"></a>静态游标demo</h4><p>静态游标：查询BONUS1表中的所有数据<br><strong>这里可以看到sql写在定义游标的时候，编译时完成查询。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">create or replace procedure curor is</span><br><span class="line">cursor v_check_names is select ENAME from BONUS1;</span><br><span class="line">v_ENAME BONUS1.ENAME%type;</span><br><span class="line">begin</span><br><span class="line">    open v_check_names;</span><br><span class="line">    loop</span><br><span class="line">      fetch v_check_names into v_ENAME;</span><br><span class="line">      exit when v_check_names%notfound;</span><br><span class="line">      dbms_output.put_line(v_ENAME);</span><br><span class="line">            </span><br><span class="line">    end loop;</span><br><span class="line">          </span><br><span class="line">    close v_check_names;</span><br><span class="line">end curor;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行结果：<br><img src="https://img-blog.csdnimg.cn/20200805192514480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="动态游标demo"><a href="#动态游标demo" class="headerlink" title="动态游标demo"></a>动态游标demo</h4><p>动态游标：查询BONUS1表3行数据<br>这里可以看到动态游标会构造sql，带有参数。sql准备好以后再执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">create or replace procedure curor is</span><br><span class="line">type cur_get_index is ref cursor; --声明一个动态游标类型</span><br><span class="line">v_cur_get_index cur_get_index;  --声明一个动态游标变量</span><br><span class="line"></span><br><span class="line">v_count number:&#x3D;3;</span><br><span class="line">v_ENAME varchar2(60);</span><br><span class="line">v_JOB varchar2(60);</span><br><span class="line">v_SAL varchar2(60);</span><br><span class="line">v_COMM varchar2(60);</span><br><span class="line">v_sql varchar2(60);</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line">      v_sql :&#x3D; &#39;select * from BONUS1 where rownum &lt;&#x3D; &#39;||v_count;</span><br><span class="line">      dbms_output.put_line(&#39;ENAME----JOB----SAL----COMM&#39;);</span><br><span class="line">      open v_cur_get_index for v_sql;    -- 打开游标，并且SQL执行结果存放到游标</span><br><span class="line">      LOOP</span><br><span class="line">          fetch v_cur_get_index into v_ENAME,v_JOB,v_SAL,v_COMM;</span><br><span class="line">          exit when v_cur_get_index%notfound;  -- 退出循环</span><br><span class="line">                    </span><br><span class="line">          dbms_output.put_line(v_ENAME||&#39;----&#39;||v_JOB||&#39;----&#39;||v_SAL||&#39;----&#39;||v_COMM);</span><br><span class="line"></span><br><span class="line">      END LOOP; -- 游标结束</span><br><span class="line">end curor;</span><br></pre></td></tr></table></figure><p>执行结果：<br><img src="https://img-blog.csdnimg.cn/20200805192818893.png" alt="在这里插入图片描述"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>静态游标：在定义的时候指明sql语句，编译时候执行。效率高。<br>动态游标：可以带有参数，编写sql处理各种复杂的业务场景。更灵活。</p><p>推荐博文：<a href="https://blog.51cto.com/375940084/1064924">存储过程静态游标、隐式游标、显式游标、动态游标、游标遍历</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;
&lt;h4 id=&quot;游标&quot;&gt;&lt;a href=&quot;#游标&quot; class=&quot;headerlink&quot; title=&quot;游标&quot;&gt;&lt;/a&gt;游标&lt;/h4&gt;&lt;p&gt;简述：存储过程代码中从表中检索出结果集进行操作交互。&lt;/p&gt;
&lt;h4 id=&quot;静态游标和动态游标&quot;&gt;&lt;a href</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Oracle存储过程引号，单引号，双引号字符串处理</title>
    <link href="http://example.com/2020/10/15/Oracle%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%BC%95%E5%8F%B7%EF%BC%8C%E5%8D%95%E5%BC%95%E5%8F%B7%EF%BC%8C%E5%8F%8C%E5%BC%95%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    <id>http://example.com/2020/10/15/Oracle%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%BC%95%E5%8F%B7%EF%BC%8C%E5%8D%95%E5%BC%95%E5%8F%B7%EF%BC%8C%E5%8F%8C%E5%BC%95%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</id>
    <published>2020-10-15T07:26:46.666Z</published>
    <updated>2020-10-15T07:44:27.190Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h4 id="常用字符串拼接引号处理："><a href="#常用字符串拼接引号处理：" class="headerlink" title="常用字符串拼接引号处理："></a>常用字符串拼接引号处理：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#39;abcdef&#39;     ---------------------------------输出：abcdef</span><br><span class="line"> &#39;aaa&#39;&#39;abcdef&#39;&#39;bbb&#39; ---------------------输出：aaa&#39;abcdef&#39;bbb</span><br><span class="line">&#39;abcdef&#39;||&#39;---mmmmm&#39;  ---------------输出：abcdef---mmmmm</span><br><span class="line">&#39;abcde&#39;&#39;&#39;||变量值||&#39;&#39;&#39;&#39; ------------------输出：abcde&#39;变量&#39;</span><br></pre></td></tr></table></figure><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><p><strong>注意：sql语句末尾不要带分号</strong><br>（1）案例一：创建表空间sql语句：<br>输出：create tablespace test4 datafile ‘/home/oracle/oradata/orcl/test4.dbf’<br> size 1m autoextend on next 5m maxsize unlimited;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v_partition_ddl:&#x3D;&#39;create tablespace &#39;||v_tablespace_name||&#39; datafile &#39;||&#39;&#39;</span><br><span class="line">&#39;&#x2F;home&#x2F;oracle&#x2F;oradata&#x2F;orcl&#x2F;&#39;||v_tablespace_name||&#39;.dbf&#39;||&#39;&#39;&#39; &#39;||&#39; </span><br><span class="line">size 1m autoextend on next 5m maxsize unlimited;&#39;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（2）案例2：insert语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v_insert_data_sql :&#x3D; &#39;INSERT INTO &#39; || v_insert_table_name || &#39;(&quot;ID&quot;, &quot;USER_ID&quot;,</span><br><span class="line"> &quot;CERT_NO&quot;, &quot;CERT_NOTAFTER_TIME&quot;, &quot;REMARK&quot;, &quot;STATUS&quot;,  &quot;CREATE_TIME&quot;) </span><br><span class="line">values(&#39;&#39;&#39;||ID||&#39;&#39;&#39;,&#39;&#39;&#39;||USER_ID||&#39;&#39;&#39;,&#39;&#39;&#39;||CERT_NO||&#39;&#39;&#39;,&#39;&#39;&#39;||CERT_NOTAFTER_TIME</span><br><span class="line">||&#39;&#39;&#39;,&#39;&#39;&#39;||REMARK||&#39;&#39;&#39;,&#39;&#39;&#39;||STATUS||&#39;&#39;&#39;,&#39;&#39;&#39;||CREATE_TIME||&#39;&#39;&#39;)&#39;;</span><br></pre></td></tr></table></figure><p> （3）案例3：查询语句（查找索引）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v_sql :&#x3D; &#39;SELECT DBMS_METADATA.GET_DDL(&#39;&#39;&#39;||CHR(73)||&#39;NDEX&#39;&#39;, index_name),</span><br><span class="line">index_name FROM USER_INDEXES WHERE table_name &#x3D; &#39;&#39;&#39;||v_base_table_name_upper||&#39;&#39;&#39; </span><br><span class="line">AND UNIQUEness &#x3D; &#39;&#39;NONUNIQUE&#39;&#39;&#39;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;
&lt;h4 id=&quot;常用字符串拼接引号处理：&quot;&gt;&lt;a href=&quot;#常用字符串拼接引号处理：&quot; class=&quot;headerlink&quot; title=&quot;常用字符串拼接引号处理：&quot;&gt;&lt;/a&gt;常用字符串拼接引号处理：&lt;/h4&gt;&lt;figure class=&quot;highl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Springboot读取yaml配置文件的三种方式（以及static注入失效的解决方式和原理）</title>
    <link href="http://example.com/2020/10/15/Springboot%E8%AF%BB%E5%8F%96yaml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%88%E4%BB%A5%E5%8F%8Astatic%E6%B3%A8%E5%85%A5%E5%A4%B1%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%E5%92%8C%E5%8E%9F%E7%90%86%EF%BC%89/"/>
    <id>http://example.com/2020/10/15/Springboot%E8%AF%BB%E5%8F%96yaml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%88%E4%BB%A5%E5%8F%8Astatic%E6%B3%A8%E5%85%A5%E5%A4%B1%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%E5%92%8C%E5%8E%9F%E7%90%86%EF%BC%89/</id>
    <published>2020-10-15T07:26:46.665Z</published>
    <updated>2020-10-15T07:44:04.868Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>初衷：<br>1.最近在搭建springboot项目的时候，使用static修饰属性遇到读取配置文件失败。<br>2.总结一下对项目配置文件整体或者拆分处理<br>注意：@PropertySource方式只对properties文件可以进行加载，但对于yml或者yaml不能支持。<br>首先看一下yaml部分配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  # 数据库配置</span><br><span class="line">  datasource:</span><br><span class="line">    druid:</span><br><span class="line">      driver-class-name: oracle.jdbc.OracleDriver</span><br><span class="line">      url: jdbc:oracle:thin:@xxx.x.x.x:1521&#x2F;orcl</span><br><span class="line">      username: scott</span><br><span class="line">      password: 12345</span><br></pre></td></tr></table></figure><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="1-value-Configuration对配置的全局处理"><a href="#1-value-Configuration对配置的全局处理" class="headerlink" title="1.@value+@Configuration对配置的全局处理"></a>1.@value+@Configuration对配置的全局处理</h4><h5 id="1-1-正确写法"><a href="#1-1-正确写法" class="headerlink" title="1.1 正确写法"></a>1.1 正确写法</h5><p>1.新建全局配置类Confignature，用于配置整个yaml的配置信息。（正确写法）<br>由下面可以看到，有2种写法<br>（1）直接在属性上面@value注解（代码简洁，但是每次使用需要先new一个Confignature对象，或者@Autowired先注入）：driver-class-name<br>（2）属性上面加static关键字修饰，@value写在对应set方法上面（不需要new，可以其他类直接调用）：url，username，password</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class Confignature &#123;</span><br><span class="line"></span><br><span class="line">    @Value(value &#x3D; &quot;$&#123;spring.datasource.druid.driver-class-name&#125;&quot;)</span><br><span class="line">    public String DATASOURCE_DRUID_DRIVER_CLASS_NAME; &#x2F;&#x2F;oracle驱动</span><br><span class="line"></span><br><span class="line">    public static String DATASOURCE_DRUID_URL; &#x2F;&#x2F;oracle url</span><br><span class="line"></span><br><span class="line">    public static String DATASOURCE_DRUID_USERNAME; &#x2F;&#x2F; oracle 用户名</span><br><span class="line"></span><br><span class="line">    public static String DATASOURCE_DRUID_PASSWORD; &#x2F;&#x2F; oracle 密码</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;spring.datasource.druid.url&#125;&quot;)</span><br><span class="line">    public void setDatasourceDruidUrl(String datasourceDruidUrl) &#123;</span><br><span class="line">        DATASOURCE_DRUID_URL &#x3D; datasourceDruidUrl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;spring.datasource.druid.username&#125;&quot;)</span><br><span class="line">    public void setDatasourceDruidUsername(String datasourceDruidUsername) &#123;</span><br><span class="line">        DATASOURCE_DRUID_USERNAME &#x3D; datasourceDruidUsername;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;spring.datasource.druid.password&#125;&quot;)</span><br><span class="line">    public void setDatasourceDruidPassword(String datasourceDruidPassword) &#123;</span><br><span class="line">        DATASOURCE_DRUID_PASSWORD &#x3D; datasourceDruidPassword;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.写一个controller测试一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private Confignature confignature;</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;&#x2F;testSpringBoot&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public void testSpringBoot() &#123;</span><br><span class="line">&#x2F;&#x2F; driver属性需要先注入confignature配置类</span><br><span class="line">    System.out.println(confignature.DATASOURCE_DRUID_DRIVER_CLASS_NAME);</span><br><span class="line">    &#x2F;&#x2F; url，usernam，password属性可以直接调用</span><br><span class="line">    System.out.println(Confignature.DATASOURCE_DRUID_URL);</span><br><span class="line">    System.out.println(Confignature.DATASOURCE_DRUID_USERNAME);</span><br><span class="line">    System.out.println(Confignature.DATASOURCE_DRUID_PASSWORD);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如图所示：成功获取值<br><img src="https://img-blog.csdnimg.cn/20200807153031446.png" alt="在这里插入图片描述"></p><h5 id="1-2-错误写法"><a href="#1-2-错误写法" class="headerlink" title="1.2 错误写法"></a>1.2 错误写法</h5><p>错误写法：<br>（1）@value注解和static同时在属性上面<br>（2）static修饰属性，但是set方法用了static修饰</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class Confignature &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 第一种错误写法</span><br><span class="line">    @Value(value &#x3D; &quot;$&#123;spring.datasource.druid.driver-class-name&#125;&quot;)</span><br><span class="line">    public static String DATASOURCE_DRUID_DRIVER_CLASS_NAME; &#x2F;&#x2F;oracle驱动</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 第二种错误写法</span><br><span class="line">    public static String DATASOURCE_DRUID_URL; &#x2F;&#x2F;oracle url</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 正确写法</span><br><span class="line">    public static String DATASOURCE_DRUID_USERNAME; &#x2F;&#x2F; oracle 用户名</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 正确写法</span><br><span class="line">    public static String DATASOURCE_DRUID_PASSWORD; &#x2F;&#x2F; oracle 密码</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;spring.datasource.druid.url&#125;&quot;)</span><br><span class="line">    public static void setDatasourceDruidUrl(String datasourceDruidUrl) &#123;</span><br><span class="line">        DATASOURCE_DRUID_URL &#x3D; datasourceDruidUrl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;spring.datasource.druid.username&#125;&quot;)</span><br><span class="line">    public void setDatasourceDruidUsername(String datasourceDruidUsername) &#123;</span><br><span class="line">        DATASOURCE_DRUID_USERNAME &#x3D; datasourceDruidUsername;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;spring.datasource.druid.password&#125;&quot;)</span><br><span class="line">    public void setDatasourceDruidPassword(String datasourceDruidPassword) &#123;</span><br><span class="line">        DATASOURCE_DRUID_PASSWORD &#x3D; datasourceDruidPassword;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下：<br><img src="https://img-blog.csdnimg.cn/20200807154608448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="2-ConfigurationProperties注解对配置进行拆分处理"><a href="#2-ConfigurationProperties注解对配置进行拆分处理" class="headerlink" title="2.ConfigurationProperties注解对配置进行拆分处理"></a>2.ConfigurationProperties注解对配置进行拆分处理</h4><p>1.新建一个配置类DatasourceConfig，注意属性名称要跟yaml配置文件一致。这里罗列正确和错误写法（不能用static修饰属性）<br>正确：driverClassName，url，username<br>错误：password<br>这种写法优势：当yaml配置文件配置信息过多，可以多写几个DatasourceConfig针对不同的配置，这样结构更为清晰</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix &#x3D; &quot;spring.datasource.druid&quot;)</span><br><span class="line">public class DatasourceConfig &#123;</span><br><span class="line"></span><br><span class="line">    private String driverClassName;</span><br><span class="line"></span><br><span class="line">    private String url ;</span><br><span class="line"></span><br><span class="line">    private String username;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 错误写法</span><br><span class="line">    private static String password;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.新写一个controller，这种方式就必须要@Autowired注入DatasourceConfig 配置类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private DatasourceConfig datasourceConfig;</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;&#x2F;testSpringBoot1&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public void testSpringBoot1() &#123;</span><br><span class="line">    System.out.println(datasourceConfig.getDriverClassName());</span><br><span class="line">    System.out.println(datasourceConfig.getUrl());</span><br><span class="line">    System.out.println(datasourceConfig.getUsername());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下：<br>由图可知，取得了3个值，password未能获取，原因在于属性用了static修饰<br><img src="https://img-blog.csdnimg.cn/20200807155404255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="3-Environment读取yaml配置文件"><a href="#3-Environment读取yaml配置文件" class="headerlink" title="3.Environment读取yaml配置文件"></a>3.Environment读取yaml配置文件</h4><p>1.新写一个controller，注入Environment 类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private Environment env;</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;&#x2F;testSpringBoot2&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public void testSpringBoot2() &#123;</span><br><span class="line">    System.out.println(env.getProperty(&quot;spring.datasource.druid.driver-class-name&quot;));</span><br><span class="line">    System.out.println(env.getProperty(&quot;spring.datasource.druid.url&quot;));</span><br><span class="line">    System.out.println(env.getProperty(&quot;spring.datasource.druid.username&quot;));</span><br><span class="line">    System.out.println(env.getProperty(&quot;spring.datasource.druid.password&quot;));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下：<br><img src="https://img-blog.csdnimg.cn/20200807160140950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="pom相关依赖"><a href="#pom相关依赖" class="headerlink" title="pom相关依赖"></a>pom相关依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置类相关--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-configuration-processor&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--druid相关--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.1.20&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;5.2.7.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--oracle相关--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.oracle&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;ojdbc6&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;11.2.0.3&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--lomback--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.18.0&lt;&#x2F;version&gt;</span><br><span class="line">  &lt;scope&gt;provided&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="源码解读为什么-value不能注入static"><a href="#源码解读为什么-value不能注入static" class="headerlink" title="源码解读为什么@value不能注入static"></a>源码解读为什么@value不能注入static</h3><p><a href="https://blog.csdn.net/chenlixiao007/article/details/105229998/">@Value注解不能注入static修饰的属性</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;初衷：&lt;br&gt;1.最近在搭建springboot项目的时候，使用static修饰属性遇到读取配置文件失败。&lt;br&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Docker报错_code 400, message Bad request syntax (‘_x16_x03_x01_x02_x00_x01_x00_x01_xfc_x03_x03_</title>
    <link href="http://example.com/2020/10/15/Docker%E6%8A%A5%E9%94%99_code%20400,%20message%20Bad%20request%20syntax%20(%E2%80%98_x16_x03_x01_x02_x00_x01_x00_x01_xfc_x03_x03_/"/>
    <id>http://example.com/2020/10/15/Docker%E6%8A%A5%E9%94%99_code%20400,%20message%20Bad%20request%20syntax%20(%E2%80%98_x16_x03_x01_x02_x00_x01_x00_x01_xfc_x03_x03_/</id>
    <published>2020-10-15T07:26:46.664Z</published>
    <updated>2020-10-15T07:43:44.212Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h4 id="docker报错"><a href="#docker报错" class="headerlink" title="docker报错"></a>docker报错</h4><p>最近学习docker的时候创建一个web项目：<br>runoob@runoob:<del># docker pull training/webapp  # 载入镜像<br>runoob@runoob:</del># docker run -d -P training/webapp python app.py</p><p>访问报错：<br>code 400, message Bad request syntax (‘\x16\x03\x01\x02\x00\x01\x00\x01\xfc\x03\x03<br>使用命令：docker logs -f  容器ID   查看日志信息<br><img src="https://img-blog.csdnimg.cn/20200811164455976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDI1ODAz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>请求的时候路径错误，用了https：<a href="https://ip:端口">https://ip:端口</a><br>正确写法，用http：<a href="http://ip:端口/">http://ip:端口/</a>    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;
&lt;h4 id=&quot;docker报错&quot;&gt;&lt;a href=&quot;#docker报错&quot; class=&quot;headerlink&quot; title=&quot;docker报错&quot;&gt;&lt;/a&gt;docker报错&lt;/h4&gt;&lt;p&gt;最近学习docker的时候创建一个web项目：&lt;br&gt;runoob</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>druid连接池以及jdbc插入修改clob类型的处理方式</title>
    <link href="http://example.com/2020/10/15/druid%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BB%A5%E5%8F%8Ajdbc%E6%8F%92%E5%85%A5%E4%BF%AE%E6%94%B9clob%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2020/10/15/druid%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BB%A5%E5%8F%8Ajdbc%E6%8F%92%E5%85%A5%E4%BF%AE%E6%94%B9clob%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</id>
    <published>2020-10-15T07:26:46.663Z</published>
    <updated>2020-10-15T07:43:02.125Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="Druid连接池处理clob字段"><a href="#Druid连接池处理clob字段" class="headerlink" title="Druid连接池处理clob字段"></a>Druid连接池处理clob字段</h2><h3 id="数据源相关"><a href="#数据源相关" class="headerlink" title="数据源相关"></a>数据源相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String sql &#x3D; &quot;&#123;call insert_timestamp(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)&#125;&quot;;</span><br><span class="line">DruidDataSource druidDataSource &#x3D; (DruidDataSource) dataSource;</span><br><span class="line">DruidPooledConnection conn &#x3D; druidDataSource.getConnection();;</span><br><span class="line">DruidPooledCallableStatement call &#x3D; (DruidPooledCallableStatement) conn.prepareCall(sql);</span><br></pre></td></tr></table></figure><h3 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Clob clob&#x3D; conn.createClob();</span><br><span class="line">clob.setString(1, &#39;插入或者修改的参数&#39;);</span><br><span class="line">ClobProxyImpl clobProxyImpl &#x3D; (ClobProxyImpl) clob;</span><br><span class="line">clob&#x3D; clobProxyImpl.getRawClob();</span><br><span class="line">call.setClob(4, clob); &#x2F;&#x2F;4为参数的位置</span><br></pre></td></tr></table></figure><h2 id="JDBC处理clob字段（下面内容为引用的其他博文，博文地址附在文尾）"><a href="#JDBC处理clob字段（下面内容为引用的其他博文，博文地址附在文尾）" class="headerlink" title="JDBC处理clob字段（下面内容为引用的其他博文，博文地址附在文尾）"></a>JDBC处理clob字段（下面内容为引用的其他博文，博文地址附在文尾）</h2><blockquote><p>方法一： Connection con = dbl.loadConnection(); strSql = “insert into<br>table1(id,a) values (1,EMPTY_CLOB())”; dbl.executeSql(strSql); String<br>str2 = “select a from table1 where id=1 “</p><p>ResultSet rs = dbl.openResultSet(str2); if(rs.next()){<br>    CLOB c = ((OracleResultSet)rs).getCLOB(“a”);<br>    c.putString(1, “长字符串”);<br>    String sql =<br>        “update table1 set a=? where id=1”;<br>    PreparedStatement pstmt = con.prepareStatement(sql);<br>    pstmt.setClob(1, c);<br>    pstmt.executeUpdate();<br>    pstmt.close(); } con.commit();</p></blockquote><blockquote><p>方法二： Connection con = dbl.loadConnection(); CLOB clob   =<br>oracle.sql.CLOB.createTemporary(con,<br>false,oracle.sql.CLOB.DURATION_SESSION); clob.putString(1,  “长字符串”);<br>Sql1 = “update table1 set a=? where id=1”; PreparedStatement pst =<br>con.prepareStatement(Sql1); pst.setClob(1, clob); pst.executeUpdate();<br>pst.close(); con.commit();</p></blockquote><p>引用博文：<a href="https://www.cnblogs.com/dyllove98/archive/2013/07/30/3226222.html">https://www.cnblogs.com/dyllove98/archive/2013/07/30/3226222.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;
&lt;h2 id=&quot;Druid连接池处理clob字段&quot;&gt;&lt;a href=&quot;#Druid连接池处理clob字段&quot; class=&quot;headerlink&quot; title=&quot;Druid连接池处理clob字段&quot;&gt;&lt;/a&gt;Druid连接池处理clob字段&lt;/h2&gt;&lt;h3 </summary>
      
    
    
    
    
  </entry>
  
</feed>
